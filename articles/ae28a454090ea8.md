---
title: "Flowãƒã‚§ãƒ¼ãƒ³ã«NFTã‚¬ãƒãƒ£ã‚’å®Ÿè£…ã—ã¦ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹"
emoji: "ğŸ”–"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["blockchain", "flow", "cadence", "TypeScript", "NextJS"]
published: true
---

Flowãƒã‚§ãƒ¼ãƒ³ã®ãƒ†ã‚¹ãƒˆãƒãƒƒãƒˆã«ã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’ãƒ‡ãƒ—ãƒ­ã‚¤ã—ã¦webãƒ•ãƒ­ãƒ³ãƒˆã‹ã‚‰æ¥ç¶šã—ã¦ã¿ãŸã®ã§ãã®å‚™å¿˜éŒ²ã§ã™ã€‚ä½œæˆã™ã‚‹ã®ã¯æŠ½é¸ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã‚‚ã£ãŸã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã§ãƒ©ãƒ³ãƒ€ãƒ ã«æŠ½é¸ã—ã¦ã‚¢ã‚¤ãƒ†ãƒ ã‚’mintã—ã¾ã™ã€‚NFTã®ã‚¬ãƒãƒ£ã®ã‚¤ãƒ¡ãƒ¼ã‚¸ã§ã™ã€‚

:::message
ä»Šå›ã‚¬ãƒãƒ£ã®æŠ½é¸ã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã«ä¹±æ•°ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ãŒã€å®Ÿéš›ã®ãƒ—ãƒ­ãƒ€ã‚¯ãƒˆãªã©ã«ã¯åˆ©ç”¨ã™ã‚‹ã«ã¯å®‰å…¨ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚ãã¾ã§å­¦ç¿’ç”¨é€”ã§ä½œæˆã—ã¾ã—ãŸã®ã§ãã®ç‚¹ã ã‘ã”æ³¨æ„ãã ã•ã„ã€‚
:::

![](https://storage.googleapis.com/zenn-user-upload/1814458f0826-20230313.gif)

Flowã€Cadenceã«ã¤ã„ã¦ã®è©³ç´°ãªèª¬æ˜ã¯æœ¬è¨˜äº‹ã§ã¯è¡Œã„ã¾ã›ã‚“ã€‚Cadenceã«ã¤ã„ã¦è©³ã—ãçŸ¥ã‚ŠãŸã„æ–¹ã¯å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦ã„ãŸã ãã‹ã‚ãŸã—ãŒåŸ·ç­†ã—ãŸ[zennæœ¬](https://zenn.dev/jy8752/books/9d4fd6fb489022)ãŒã‚ã‚Šã¾ã™ã®ã§ã‚ˆã‘ã‚Œã°ã”å‚ç…§ãã ã•ã„ã€‚

##  ã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ä½œæˆ

ã¾ãšã¯Flow CLIã§é››å½¢ã‚’ä½œæˆã—ã¾ã™ã€‚

```
flow setup gacha-nft
```

### ã‚¬ãƒãƒ£ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã‚’ä½œæˆ

ã‚¬ãƒãƒ£ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹ãŸã‚ã®å‡¦ç†ã‚’ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã‚’ä½œæˆã™ã‚‹ã“ã¨ã§æŠ½è±¡åŒ–ã—ã¾ã™ã€‚ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã«å®Ÿè£…ã™ã‚‹æ©Ÿèƒ½ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚

#### Item

ã‚¬ãƒãƒ£ã®ã‚¢ã‚¤ãƒ†ãƒ æŠ½é¸ã«ã¯æ’å‡ºã‚¢ã‚¤ãƒ†ãƒ ãã‚Œãã‚Œã«ä¸€å®šã®é‡ã¿ã‚’è¨­å®šã—ã€æŠ½é¸æ™‚ã«é‡ã¿ä»˜ã‘æŠ½é¸ãŒã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚å„ã‚¢ã‚¤ãƒ†ãƒ ã¯idã‚’å‰²ã‚ŠæŒ¯ã‚Škeyã«id, valueã«ã‚¢ã‚¤ãƒ†ãƒ ã®é‡ã¿ã¨ã—ãŸè¾æ›¸å‹ã®å¤‰æ•°ã‚’ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«æŒãŸã›ã¾ã™ã€‚

```ts:Gacha.cdc
pub contract interface Gacha {
    /// æŠ½é¸mintã™ã‚‹ãŸã‚ã®é‡ã¿è¨­å®š Weight setting for lottery minting
    pub struct interface HasWeight {
      /// é‡ã¿ weight
      pub let weight: UInt64
    }

    /// ã‚¬ãƒãƒ£ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‹ã‚‰mintã•ã‚Œã‚‹ã‚¢ã‚¤ãƒ†ãƒ 
    /// item minted by this gacha contract
    pub struct Item: HasWeight {
      pub let weight: UInt64
    }

    /// key: item_id value: item
    pub let ids: {UInt64: AnyStruct{HasWeight}}
```

#### Collection

ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒä¿æŒã™ã‚‹Collectionãƒªã‚½ãƒ¼ã‚¹ã®å®šç¾©ã‚’ã—ã¾ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã©ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã„ãã¤æŒã£ã¦ã„ã‚‹ã‹ã®æƒ…å ±ã¨æ•°é‡ã®å¢—æ¸›ã€æ•°é‡ã®å–å¾—é–¢æ•°ã®å®šç¾©ã‚’ã—ã¾ã™ã€‚

```ts:Gacha.cdc
    pub resource interface IncreceAmount {
      pub fun increceAmount(id: UInt64, amount: UInt32)
    }

    pub resource interface DecreceAmount {
      pub fun decreseAmount(id: UInt64, amount: UInt32)
    }

    pub resource interface GetAmounts {
      pub fun getAmount(id: UInt64): UInt32
      pub fun getAmounts(): {UInt64:UInt32}
    }

    pub resource Collection: IncreceAmount, DecreceAmount, GetAmounts {
      /// key: item_id value: amount
      pub var ownedAmounts: {UInt64:UInt32}

      /// increce the item amount
      pub fun increceAmount(id: UInt64, amount: UInt32)

      /// decrece the item amount.
      /// must have more than specifyed amount.
      pub fun decreseAmount(id: UInt64, amount: UInt32) {
        pre {
          self.ownedAmounts[id] == nil: "Not have token!!"
          self.ownedAmounts[id]! - amount < 0: "The amount you do not have is specified!"
        }
      }

      /// get specified id item amount 
      pub fun getAmount(id: UInt64): UInt32

      /// get all item id and amount
      pub fun getAmounts(): {UInt64:UInt32}
    }
```

ãƒ•ã‚¡ã‚¤ãƒ«ã®å…¨ä½“ã¯ä»¥ä¸‹ã®ã‚ˆã†ãªæ„Ÿã˜ã§ã™ã€‚

```ts:Gacha.cdc
/// NFTã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã«ã‚¬ãƒãƒ£ã®æ©Ÿèƒ½ã‚’çµ„ã¿è¾¼ã‚€ãŸã‚ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹
/// ã“ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ãŒå®Ÿè£…ã•ã‚ŒãŸã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆãŒï¼‘ã¤ã®ã‚¬ãƒãƒ£ç­ä½“ã‚’è¡¨ç¾ã™ã‚‹
/// Interface to incorporate gacha functionality into NFT collectionss.
/// The contract in which this interface is implemented represents a single mess enclosure.
pub contract interface Gacha {
    /// increce amount event
    pub event Increce(id: UInt64, beforeAmount: UInt32, afterAmount: UInt32)
    /// decrece amount event
    pub event Decrece(id: UInt64, beforeAmount: UInt32, afterAmount: UInt32)

    /// æŠ½é¸mintã™ã‚‹ãŸã‚ã®é‡ã¿è¨­å®š Weight setting for lottery minting
    pub struct interface HasWeight {
      /// é‡ã¿ weight
      pub let weight: UInt64
    }

    /// ã‚¬ãƒãƒ£ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‹ã‚‰mintã•ã‚Œã‚‹ã‚¢ã‚¤ãƒ†ãƒ 
    /// item minted by this gacha contract
    pub struct Item: HasWeight {
      pub let weight: UInt64
    }

    /// key: item_id value: item
    pub let ids: {UInt64: AnyStruct{HasWeight}}

    pub resource interface IncreceAmount {
      pub fun increceAmount(id: UInt64, amount: UInt32)
    }

    pub resource interface DecreceAmount {
      pub fun decreseAmount(id: UInt64, amount: UInt32)
    }

    pub resource interface GetAmounts {
      pub fun getAmount(id: UInt64): UInt32
      pub fun getAmounts(): {UInt64:UInt32}
    }

    pub resource Collection: IncreceAmount, DecreceAmount, GetAmounts {
      /// key: item_id value: amount
      pub var ownedAmounts: {UInt64:UInt32}

      /// increce the item amount
      pub fun increceAmount(id: UInt64, amount: UInt32)

      /// decrece the item amount.
      /// must have more than specifyed amount.
      pub fun decreseAmount(id: UInt64, amount: UInt32) {
        pre {
          self.ownedAmounts[id] == nil: "Not have token!!"
          self.ownedAmounts[id]! - amount < 0: "The amount you do not have is specified!"
        }
      }

      /// get specified id item amount 
      pub fun getAmount(id: UInt64): UInt32

      /// get all item id and amount
      pub fun getAmounts(): {UInt64:UInt32}
    }
}
```

### NonFungibleTokenã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆ

Flowã§NFTã‚’å®Ÿè£…ã™ã‚‹å ´åˆã€æ—¢ã«ç”¨æ„ã•ã‚Œã¦ã„ã‚‹ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’ã„ãã¤ã‹ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

https://github.com/onflow/flow-nft/tree/master/contracts

ä»Šå›ã¯ã“ã‚Œã‚‰ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‹ã‚‰```NonFungibleToken```, ```MetadataViews```, ```FungibleToken```ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦é…ç½®ã—ã¾ã™ã€‚

```
.
â”œâ”€â”€ contracts
â”‚Â Â  â”œâ”€â”€ Gacha.cdc
â”‚Â Â  â””â”€â”€ lib
â”‚Â Â      â”œâ”€â”€ MetadataViews.cdc
â”‚Â Â      â”œâ”€â”€ NonFungibleToken.cdc
â”‚Â Â      â””â”€â”€ utility
â”‚Â Â          â””â”€â”€ FungibleToken.cdc
```

:::message
NFTã®å®Ÿè£…ã«ã¯ã“ã®NonFungibleTokenãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã“ã¨ãŒæ¨å¥¨ã•ã‚Œã¦ã„ã¾ã™ã€‚
:::

:::message
Flowã®NFTã¯[NFT Catalog](https://www.flow-nft-catalog.com/)ã¨ã„ã†ã‚µã‚¤ãƒˆã§ã‚«ã‚¿ãƒ­ã‚°ã¨ã—ã¦ä¸€è¦§è¡¨ç¤ºã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚NFT Catalogã«æº–æ‹ ã™ã‚‹ãŸã‚ã«NFTã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«MetadataViewsã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’å®Ÿè£…ã•ã›ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
:::

### ã‚¬ãƒãƒ£ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®å®Ÿè£…

ä½œæˆã—ãŸã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã‚’ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«å®Ÿè£…ã—ã¾ã™ã€‚

#### ã‚¢ã‚¤ãƒ†ãƒ ã‚’æŠ½é¸ã™ã‚‹ãŸã‚ã®idsãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰

ä»¥ä¸‹ã®ã‚ˆã†ãªidã¨Itemã®æ§‹é€ ä½“ã®å¯¾å¿œè¡¨ã‚’ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã§ä¿æŒã•ã›ã€æŠ½é¸ã«åˆ©ç”¨ã—ã¾ã™ã€‚

```ts:GachaNFT.cdc
    /// NFTã¨ã—ã¦ç™ºè¡Œã™ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³æƒ…å ±
    pub struct Item: Gacha.HasWeight {
      pub let id: UInt64
      pub let name: String
      pub let description: String
      pub let thumbnail: String
      pub let weight: UInt64

      init(
        id: UInt64,
        name: String,
        description: String,
        thumbnail: String,
        rarity: String,
        weight: UInt64
      ) {
        self.id = id
        self.name = name
        self.description = description
        self.thumbnail = thumbnail
        self.weight = weight
      }
    }

    /// key: token_kind_id value: token_info
    pub let ids: {UInt64: AnyStruct{Gacha.HasWeight}}
```

#### NFTãƒªã‚½ãƒ¼ã‚¹

1ã‚¢ã‚¤ãƒ†ãƒ æƒ…å ±ã‚’è¡¨ã™NFTãƒªã‚½ãƒ¼ã‚¹ã®å®šç¾©ã€‚idã‚„ã‚µãƒ ãƒã‚¤ãƒ«ç”»åƒãªã©ã®æƒ…å ±ã‚’æŒãŸã›ã‚‹ã€‚

```ts:GachaNFT.cdc
    // NonFungibleToken override
    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
      // NonfungibleToken.INFT override token kind id(not unique)
      pub let id: UInt64

      /// metadata
      pub let name: String
      pub let description: String
      pub let thumbnail: String
      access(self) let royalties: [MetadataViews.Royalty]
      access(self) let metadata: {String: AnyStruct}

      init(
        id: UInt64,
        name: String,
        description: String,
        thumbnail: String,
        royalties: [MetadataViews.Royalty],
        metadata: {String: AnyStruct}
      ) {
        self.id = id
        self.name = name
        self.description = description
        self.thumbnail = thumbnail
        self.royalties = royalties
        self.metadata = metadata
      }
    
    ç•¥)
```

#### ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ãƒªã‚½ãƒ¼ã‚¹

ã“ã®ã‚¬ãƒãƒ£NFTã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ãƒªã‚½ãƒ¼ã‚¹ã€‚ã“ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®NFTãƒˆãƒ¼ã‚¯ãƒ³ã‚’mintã™ã‚‹ã«ã¯ã“ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ãƒªã‚½ãƒ¼ã‚¹ã‚’ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜ã—ã¾ã™ã€‚ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã¯æ‰€æŒã—ã¦ã„ã‚‹NFTæƒ…å ±ã¨NFTã®æ‰€æŒæ•°ãªã©ã‚’ä¿æŒã—ã¾ã™ã€‚

```ts:GachaNFT.cdc
    // NonFungibleToken override
    pub resource Collection: 
      GachaNFTCollectionPublic,
      NonFungibleToken.Provider,
      NonFungibleToken.Receiver,  
      NonFungibleToken.CollectionPublic, 
      MetadataViews.ResolverCollection,
      Gacha.IncreceAmount,
      Gacha.DecreceAmount,
      Gacha.GetAmounts
    {
      // NonFungibleToken.Collection override
      pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

      pub var ownedAmounts: {UInt64: UInt32}

      init() {
        self.ownedNFTs <- {}
        self.ownedAmounts = {}
      } 
  ç•¥)
```

#### NFTMinter

NFTã‚’mintã™ã‚‹ãŸã‚ã®minterãƒªã‚½ãƒ¼ã‚¹ã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã—ã¾ã™ã€‚

```ts:GachaNFT.cdc
    pub resource NFTMinter {
    
      pub fun mint(
        recipient: &{NonFungibleToken.CollectionPublic},
        royalties: [MetadataViews.Royalty],
        item: Item,
      ) {
          let metadata: {String: AnyStruct} = {}
          let currentBlock = getCurrentBlock()
          metadata["mintedBlock"] = currentBlock.height
          metadata["mintedTime"] = currentBlock.timestamp
          metadata["minter"] = recipient.owner!.address

          // create a new NFT
          var newNFT <- create NFT(
              id: item.id,
              name: item.name,
              description: item.description,
              thumbnail: item.thumbnail,
              royalties: royalties,
              metadata: metadata,
          )

          // deposit it in the recipient's account using their reference
          recipient.deposit(token: <-newNFT)

          GachaNFT.totalSupply = GachaNFT.totalSupply + 1
      }
    }
```

#### ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®åˆæœŸåŒ–

ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®åˆæœŸåŒ–å‡¦ç†ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã—ã¾ã™ã€‚æœ¬å½“ã¯ã‚¬ãƒãƒ£ã®æ’å‡ºã‚¢ã‚¤ãƒ†ãƒ ã®åˆæœŸåŒ–ã«ã¯ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆãƒ‡ãƒ—ãƒ­ã‚¤æ™‚ã®å¼•æ•°ãªã©ã§æ¸¡ã™ã‚ˆã†ã«ã—ãŸã‹ã£ãŸã®ã§ã™ãŒä¸€æ—¦åˆæœŸåŒ–å‡¦ç†ã«ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã—ã¦ã„ã¾ã™ã€‚

```ts:GachaNFT.cdc
    init() {
      self.totalSupply = 0
      
      // ãƒ‘ã‚¹ã®åˆæœŸåŒ–
      self.CollectionStoragePath = StoragePath(identifier: "GachaNFTCollection") ?? panic("can not specify storage path.")
      self.CollectionPublicPath = PublicPath(identifier: "GachaNFTCollection") ?? panic("can not specify public path.")
      self.MinterStoragePath = StoragePath(identifier: "GachaNFTMinter") ?? panic("can not specify storage path.")
      self.GachaPublicPath = PublicPath(identifier: "GachaPublic") ?? panic("can not specify public path.")

      // ã“ã®ã‚¬ãƒãƒ£ã®æ’å‡ºã‚¢ã‚¤ãƒ†ãƒ åˆæœŸåŒ–
      self.ids = {
        1: Item(
          id: 1, name: "Item1", description: "Normal item.", thumbnail: "QmSzzQjaQSsUgYpxXxtF1mRgUzFYKh5HZQRi2RehNs8ZhH", rarity: "N", weight: 60
        ),
        2: Item(
          id: 2, name: "Item2", description: "Rea item.", thumbnail: "QmeHqCZ2M3FJa1J91Rd8arhKj5UBAmbs4i3mHxs6QVz6xS", rarity: "R", weight: 30
        ),
        3: Item(
          id: 3, name: "Item3", description: "Super Rea item.", thumbnail: "QmQCrYirym911cBSygYX84sWmUmirtRqpXiZFVr67s5pm7", rarity: "SR", weight: 10
        )
      }
    }
```

ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®æœ€çµ‚çš„ãªå®Ÿè£…ã¯ã“ã¡ã‚‰ã§ã™ã€‚
:::details ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®æœ€çµ‚çš„ãªå®Ÿè£…
```ts:GachaNFT.cdc
import NonFungibleToken from "./lib/NonFungibleToken.cdc"
import MetadataViews from "./lib/MetadataViews.cdc"
import Gacha from "./Gacha.cdc"

pub contract GachaNFT: NonFungibleToken, Gacha {
    // NonFungibleToken override
    pub var totalSupply: UInt64

    /// event
    // NonFungibleToken override
    pub event ContractInitialized()
    // NonFungibleToken override
    pub event Withdraw(id: UInt64, from: Address?)
    // NonFungibleToken override
    pub event Deposit(id: UInt64, to: Address?)

    pub event Increce(id: UInt64, beforeAmount: UInt32, afterAmount: UInt32)
    pub event Decrece(id: UInt64, beforeAmount: UInt32, afterAmount: UInt32)

    /// path
    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath
    pub let GachaPublicPath: PublicPath

    /// NFTã¨ã—ã¦ç™ºè¡Œã™ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³æƒ…å ±
    pub struct Item: Gacha.HasWeight {
      pub let id: UInt64
      pub let name: String
      pub let description: String
      pub let thumbnail: String
      pub let weight: UInt64

      init(
        id: UInt64,
        name: String,
        description: String,
        thumbnail: String,
        rarity: String,
        weight: UInt64
      ) {
        self.id = id
        self.name = name
        self.description = description
        self.thumbnail = thumbnail
        self.weight = weight
      }
    }

    /// key: token_kind_id value: token_info
    pub let ids: {UInt64: AnyStruct{Gacha.HasWeight}}

    // NonFungibleToken override
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
      return <- create Collection()
    }

    // NonFungibleToken override
    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
      // NonfungibleToken.INFT override token kind id(not unique)
      pub let id: UInt64

      /// metadata
      pub let name: String
      pub let description: String
      pub let thumbnail: String
      access(self) let royalties: [MetadataViews.Royalty]
      access(self) let metadata: {String: AnyStruct}

      init(
        id: UInt64,
        name: String,
        description: String,
        thumbnail: String,
        royalties: [MetadataViews.Royalty],
        metadata: {String: AnyStruct}
      ) {
        self.id = id
        self.name = name
        self.description = description
        self.thumbnail = thumbnail
        self.royalties = royalties
        self.metadata = metadata
      }
    
      // MetadaViews.Resolver override 
      pub fun getViews(): [Type] {
        return [
            Type<MetadataViews.Display>(),
            Type<MetadataViews.Royalties>(),
            Type<MetadataViews.Editions>(),
            Type<MetadataViews.ExternalURL>(),
            Type<MetadataViews.NFTCollectionData>(),
            Type<MetadataViews.NFTCollectionDisplay>(),
            Type<MetadataViews.Serial>(),
            Type<MetadataViews.Traits>()
        ]
      }

      // MetadaViews.Resolver override 
      pub fun resolveView(_ view: Type): AnyStruct? {
        switch view {
          // basic view thumbnail is http url or ipfs path
          case Type<MetadataViews.Display>():
            return MetadataViews.Display(
                name: self.name,
                description: self.description,
                thumbnail: MetadataViews.IPFSFile(
                    cid: self.thumbnail,
                    path: nil
                )
            )
          // è¤‡æ•°ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç™ºè¡Œã™ã‚‹ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³
          case Type<MetadataViews.Editions>():
            let editionInfo = MetadataViews.Edition(
              name: "Example NFT Edition", // ex) Play, Series...
              number: self.id, // #20/100 ã®20ã®éƒ¨åˆ†
              max: nil // #20/100ã®100ã®éƒ¨åˆ†ã€‚ç„¡åˆ¶é™ã®å ´åˆã¯nil
            )
            let editionList: [MetadataViews.Edition] = [editionInfo]
            return MetadataViews.Editions(
                editionList
            )
          // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå†…ã®ä»–ã®NFTã®é–“ã§ä¸€æ„ã¨ãªã‚‹Serial number
          case Type<MetadataViews.Serial>():
            return MetadataViews.Serial(self.id)
          // ãƒ­ã‚¤ãƒ¤ãƒªãƒ†ã‚£ãƒ¼æƒ…å ±
          case Type<MetadataViews.Royalties>():
            return MetadataViews.Royalties(self.royalties)
          // å¤–éƒ¨URL
          case Type<MetadataViews.ExternalURL>():
            return MetadataViews.ExternalURL("https://example.com/".concat(self.id.toString()))
          // NFTã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³æƒ…å ±
          case Type<MetadataViews.NFTCollectionData>():
            return MetadataViews.NFTCollectionData(
              storagePath: GachaNFT.CollectionStoragePath, // NFTã®ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãƒ‘ã‚¹
              publicPath: GachaNFT.CollectionPublicPath, // NFTã®å‚ç…§publicãƒ‘ã‚¹
              providerPath: /private/GachaNFTCollection, // NFTã®å‚ç…§privateãƒ‘ã‚¹
              publicCollection: Type<&GachaNFT.Collection{GachaNFT.GachaNFTCollectionPublic}>(), // publicãªNFTã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å‹.é€šå¸¸ã€ä»¥ä¸‹ã®publicLinkedTypeã¨ä¸€è‡´ã™ã‚‹ãŒå¤ã„ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®ä¸‹ä½äº’æ›ã®ãŸã‚ã«ã‚ã‚‹
              publicLinkedType: Type<&GachaNFT.Collection{GachaNFT.GachaNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(),
              // å‰è¿°ã®privateãƒ‘ã‚¹ã«ã‚ã‚‹å‚ç…§ã®å‹
              providerLinkedType: Type<&GachaNFT.Collection{GachaNFT.GachaNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(), 
              createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                  return <-GachaNFT.createEmptyCollection()
              })
            )
          // NFTã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¡¨ç¤ºã™ã‚‹ã®ã«å¿…è¦ãªæƒ…å ±
          case Type<MetadataViews.NFTCollectionDisplay>():
            let media = MetadataViews.Media(
              file: MetadataViews.IPFSFile(
                cid: "QmTA3bk8GiXDnNdtLKWzXVGQxNqbfQv7WKZ7YoqCHCs6bJ",
                path: nil
              ),
              mediaType: "image/svg+xml"
            )
            return MetadataViews.NFTCollectionDisplay(
                name: "GachaNFT Collection",
                description: "This collection has Gacha feature.",
                externalURL: MetadataViews.ExternalURL("https://xxxxx"),
                squareImage: media, // ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®ã‚¹ã‚¯ã‚¨ã‚¢ç”»åƒ
                bannerImage: media, // ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒãƒŠãƒ¼ç”»åƒ
                // SNSãªã©
                socials: {
                    "twitter": MetadataViews.ExternalURL("https://twitter.com/xxxxxx")
                }
            )
          // key-valueã§å–ã‚Šå‡ºã›ã‚‹å±æ€§çš„ãªã‚„ã¤
          case Type<MetadataViews.Traits>():
            // exclude mintedTime and foo to show other uses of Traits
            let excludedTraits = ["mintedTime", "foo"]
            let traitsView = MetadataViews.dictToTraits(dict: self.metadata, excludedNames: excludedTraits)

            // mintedTime is a unix timestamp, we should mark it with a displayType so platforms know how to show it.
            let mintedTimeTrait = MetadataViews.Trait(name: "mintedTime", value: self.metadata["mintedTime"]!, displayType: "Date", rarity: nil)
            traitsView.addTrait(mintedTimeTrait)

            // foo is a trait with its own rarity
            let fooTraitRarity = MetadataViews.Rarity(score: 10.0, max: 100.0, description: "Common")
            let fooTrait = MetadataViews.Trait(name: "foo", value: self.metadata["foo"], displayType: nil, rarity: fooTraitRarity)
            traitsView.addTrait(fooTrait)
            
            return traitsView
        }
        return nil
      }
    }

    // publicã«å…¬é–‹ã™ã‚‹æ©Ÿèƒ½ç¾¤
    pub resource interface GachaNFTCollectionPublic {
      pub fun deposit(token: @NonFungibleToken.NFT)
      pub fun getIDs(): [UInt64]
      pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
      pub fun borrowGachaNFT(id: UInt64): &GachaNFT.NFT? {
          post {
              (result == nil) || (result?.id == id):
                  "Cannot borrow ExampleNFT reference: the ID of the returned reference is incorrect"
          }
      }
    }

    // NonFungibleToken override
    pub resource Collection: 
      GachaNFTCollectionPublic,
      NonFungibleToken.Provider,
      NonFungibleToken.Receiver,  
      NonFungibleToken.CollectionPublic, 
      MetadataViews.ResolverCollection,
      Gacha.IncreceAmount,
      Gacha.DecreceAmount,
      Gacha.GetAmounts
    {
      // NonFungibleToken.Collection override
      pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

      pub var ownedAmounts: {UInt64: UInt32}

      init() {
        self.ownedNFTs <- {}
        self.ownedAmounts = {}
      } 

      pub fun increceAmount(id: UInt64, amount: UInt32) {
        let beforeAmount = self.ownedAmounts[id] ?? panic("Does Not have token, so instedof deposit!")
        let afterAmount = beforeAmount + amount
        self.ownedAmounts[id] = afterAmount

        emit Increce(id: id, beforeAmount: beforeAmount, afterAmount: afterAmount)
      }

      pub fun decreseAmount(id: UInt64, amount: UInt32) {
        let beforeAmount = self.ownedAmounts[id] ?? panic("Does Not have token!")
        let afterAmount = beforeAmount - amount
        self.ownedAmounts[id] = afterAmount

        emit Decrece(id: id, beforeAmount: beforeAmount, afterAmount: afterAmount)

        if(afterAmount == 0) {
          // ãªããªã£ãŸã®ã§ãƒªã‚½ãƒ¼ã‚¹ã‚‚æ¶ˆã™
          destroy self.withdraw(withdrawID: id)
        }
      }

      pub fun getAmount(id: UInt64): UInt32 {
        return self.ownedAmounts[id] ?? 0
      }

      pub fun getAmounts(): {UInt64:UInt32} {
        return self.ownedAmounts
      }

      // NonFungibleToken.Provider override
      pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
        let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")
        self.ownedAmounts.remove(key: withdrawID)               

        emit Withdraw(id: token.id, from: self.owner?.address)

        return <-token
      }

      // NonFungibleToken.Receiver override
      pub fun deposit(token: @NonFungibleToken.NFT) {
        pre {
          self.ownedAmounts[token.id] == nil || self.ownedAmounts[token.id]! <= 0: "Already owned!"
        }
        let token <- token as! @GachaNFT.NFT // important! castã™ã‚‹å¿…è¦ãŒã‚ã‚‹
        let id: UInt64 = token.id

        // add the new token to the dictionary which removes the old one
        let oldToken <- self.ownedNFTs[id] <- token

        self.ownedAmounts[id] = 1

        emit Deposit(id: id, to: self.owner?.address)

        destroy oldToken
      }

      // NonFungibleToken.CollectionPublic override
      pub fun getIDs(): [UInt64] {
          return self.ownedNFTs.keys
      }

      // NonFungibleToken.CollectionPublic override
      pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
          return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
      }
 
      // GachaNFTCollectionPublic override
      pub fun borrowGachaNFT(id: UInt64): &GachaNFT.NFT? {
          if self.ownedNFTs[id] != nil {
              // Create an authorized reference to allow downcasting
              let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
              return ref as! &GachaNFT.NFT
          }

          return nil
      }

      // MetadataViews.ResolverCollection override
      pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
          let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
          let gachaNFT = nft as! &GachaNFT.NFT
          return gachaNFT
      }

      destroy() {
          destroy self.ownedNFTs
          self.ownedAmounts = {}
      }
    }

    pub resource NFTMinter {
    
      pub fun mint(
        recipient: &{NonFungibleToken.CollectionPublic},
        royalties: [MetadataViews.Royalty],
        item: Item,
      ) {
          let metadata: {String: AnyStruct} = {}
          let currentBlock = getCurrentBlock()
          metadata["mintedBlock"] = currentBlock.height
          metadata["mintedTime"] = currentBlock.timestamp
          metadata["minter"] = recipient.owner!.address

          // create a new NFT
          var newNFT <- create NFT(
              id: item.id,
              name: item.name,
              description: item.description,
              thumbnail: item.thumbnail,
              royalties: royalties,
              metadata: metadata,
          )

          // deposit it in the recipient's account using their reference
          recipient.deposit(token: <-newNFT)

          GachaNFT.totalSupply = GachaNFT.totalSupply + 1
      }
    }

    pub fun createNFTMinter(): @NFTMinter {
      return <- create NFTMinter()
    }

    init() {
      self.totalSupply = 0
      
      self.CollectionStoragePath = StoragePath(identifier: "GachaNFTCollection") ?? panic("can not specify storage path.")
      self.CollectionPublicPath = PublicPath(identifier: "GachaNFTCollection") ?? panic("can not specify public path.")
      self.MinterStoragePath = StoragePath(identifier: "GachaNFTMinter") ?? panic("can not specify storage path.")
      self.GachaPublicPath = PublicPath(identifier: "GachaPublic") ?? panic("can not specify public path.")

      // TODO ã‚³ãƒ³ãƒˆãƒ©ã‚¯ã‚¿å¼•æ•°ã«ã™ã‚‹
      self.ids = {
        1: Item(
          id: 1, name: "Item1", description: "Normal item.", thumbnail: "QmSzzQjaQSsUgYpxXxtF1mRgUzFYKh5HZQRi2RehNs8ZhH", rarity: "N", weight: 60
        ),
        2: Item(
          id: 2, name: "Item2", description: "Rea item.", thumbnail: "QmeHqCZ2M3FJa1J91Rd8arhKj5UBAmbs4i3mHxs6QVz6xS", rarity: "R", weight: 30
        ),
        3: Item(
          id: 3, name: "Item3", description: "Super Rea item.", thumbnail: "QmQCrYirym911cBSygYX84sWmUmirtRqpXiZFVr67s5pm7", rarity: "SR", weight: 10
        )
      }
    }
}
```
:::

### mintã—ã¦ã¿ã‚‹

ã¾ãšã¯ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚’ã—ã¾ã™ã€‚

```ts:setup_account.cdc
import GachaNFT from "../contracts/GachaNFT.cdc"
import Gacha from "../contracts/Gacha.cdc"
import NonFungibleToken from "../contracts/lib/NonFungibleToken.cdc"

transaction {
  prepare(signer: AuthAccount) {
    // æ—¢ã«ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’æŒã£ã¦ã„ã‚‹
    if signer.borrow<&GachaNFT.Collection>(from: GachaNFT.CollectionStoragePath) != nil {
      return
    }

    // ãƒªã‚½ãƒ¼ã‚¹ä½œæˆ
    let collection <- GachaNFT.createEmptyCollection()

    // ãƒªã‚½ãƒ¼ã‚¹ä¿å­˜
    signer.save(<- collection, to: GachaNFT.CollectionStoragePath)

    // linkã®ä½œæˆ
    signer.link<&{NonFungibleToken.CollectionPublic}>(
      GachaNFT.CollectionPublicPath,
      target: GachaNFT.CollectionStoragePath
    )

    signer.link<&{Gacha.IncreceAmount, Gacha.GetAmounts}>(
      GachaNFT.GachaPublicPath,
      target: GachaNFT.CollectionStoragePath
    )

    log("complete setup!!")
  }
}
```

```ts:setup_nft_minter.cdc
/*
ç®¡ç†è€…ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã§å®Ÿè¡Œã™ã‚‹
NFTã‚’mintã™ã‚‹ãŸã‚ã®minterãƒªã‚½ãƒ¼ã‚¹ã‚’ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜ã™ã‚‹
 */
import GachaNFT from "../contracts/GachaNFT.cdc"
import NonFungibleToken from "../contracts/lib/NonFungibleToken.cdc"

transaction {
  prepare(signer: AuthAccount) {
    let minter <- GachaNFT.createNFTMinter()
    signer.save(<- minter, to: GachaNFT.MinterStoragePath)
    log("complete setup minter!!")
  }
}
```

æº–å‚™ãŒã§ããŸã‚‰mintã—ã¦ã¿ã¾ã™ã€‚

```ts:lottery_mint.cdc
import GachaNFT from "../contracts/GachaNFT.cdc"
import Gacha from "../contracts/Gacha.cdc"
import NonFungibleToken from "../contracts/lib/NonFungibleToken.cdc"

transaction(
    recipient: Address
) {
    let minter: &GachaNFT.NFTMinter
    let recipientCollectionRef: &{NonFungibleToken.CollectionPublic}
    let gachaRef: &{Gacha.IncreceAmount, Gacha.GetAmounts}

    prepare(acct: AuthAccount) {
        self.minter = acct.borrow<&GachaNFT.NFTMinter>(from: GachaNFT.MinterStoragePath)
            ?? panic("Account does not store minter object at the specify storage path")
        
        self.recipientCollectionRef = getAccount(recipient)
            .getCapability(GachaNFT.CollectionPublicPath)
            .borrow<&{NonFungibleToken.CollectionPublic}>()
            ?? panic("Account does not store collection object at the specify public path")
        
        self.gachaRef = getAccount(recipient)
            .getCapability(GachaNFT.GachaPublicPath)
            .borrow<&{Gacha.IncreceAmount, Gacha.GetAmounts}>()
            ?? panic("Account does not store collection object at the specify public path")

    }

    execute {
        // ã‚¢ã‚¤ãƒ†ãƒ ã¨é‡ã¿ã®å¯¾å¿œè¡¨
        let ids = GachaNFT.ids

        // é‡ã¿ã®ç·å’Œ
        var total: UInt64 = 0
        ids.forEachKey(fun (id: UInt64): Bool {
            let item = ids[id]
            if item != nil {
                total = total + item!.weight
                return true
            } else {
                return false
            }
        })

        // ä¹±æ•°
        let rand = unsafeRandom() % total // 0 ~ (total - 1)ã¾ã§ã®ä¹±æ•°
        // é‡ã¿ä»˜ã‘æŠ½é¸
        var currentWeight: UInt64 = 0
        var lotteryItem: GachaNFT.Item? = nil
        for i, key in ids.keys {
            let item = ids[key]!
            currentWeight = currentWeight + item.weight
            if rand < currentWeight {
                lotteryItem = item as? GachaNFT.Item ?? panic("LotteryItem type is not GachaNFT.Item!!")
                break
            }
        }

        // ãŸã¶ã‚“ã‚ã‚Šãˆãªã„
        if lotteryItem == nil {
            panic("Fail lottery NFT!")
        }

        if self.gachaRef.getAmount(id: lotteryItem!.id) == 0 {
            // ã¾ã æŒã£ã¦ãªã„ãƒˆãƒ¼ã‚¯ãƒ³ãªã®ã§æ™®é€šã«mintã™ã‚‹
            self.minter.mint(
                recipient: self.recipientCollectionRef,
                royalties: [],
                item: lotteryItem!
            )
            log("execute mint!!")
        } else {
            // æ—¢ã«æŒã£ã¦ã‚‹ã®ã§å€‹æ•°ã‚’å¢—ã‚„ã™
            self.gachaRef.increceAmount(id: lotteryItem!.id, amount: 1)
            log("increce item amount!!")
        }

        log("complete lottery!!")
    }
}
```

ä»Šå›NFTã‚¬ãƒãƒ£ã¨ã„ã†ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’ä½œã‚Šã¾ã—ãŸãŒå®Ÿéš›ã®æŠ½é¸å‡¦ç†ã¯transactionã®å‡¦ç†å†…ã«å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚æœ¬å½“ã¯ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆå†…ã§æŠ½é¸ã¾ã§ã§ãã¦ã‚Œã°è‰¯ã‹ã£ãŸã®ã§ã™ãŒã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆå†…ã§ä¹±æ•°ã‚’ä½¿ç”¨ã™ã‚‹éš›ã«å®‰å…¨ã«åˆ©ç”¨ã™ã‚‹ã®ãŒé›£ã—ã„ã§ã™ã€‚ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆå†…ã§ã®ä¹±æ•°ã®æ‰±ã„ã«ã¤ã„ã¦ã¯ä»¥ä¸‹ã®è¨˜äº‹ãŒå¤§å¤‰å‹‰å¼·ã«ãªã‚Šã¾ã—ãŸã®ã§è©³ã—ãçŸ¥ã‚ŠãŸã„æ–¹ã¯ã”å‚ç…§ãã ã•ã„ã€‚

https://medium.com/flow-japan/flow-nft-random-parameter-f8a6baf95dd9

### ãƒ†ã‚¹ãƒˆãƒãƒƒãƒˆã«ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹

æœ€å¾Œã«å®Ÿè£…ã—ãŸã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’ãƒ†ã‚¹ãƒˆãƒãƒƒãƒˆã«ãƒ‡ãƒ—ãƒ­ã‚¤ã—ã¾ã™ã€‚flow.jsonã«ä»¥ä¸‹ã®ã‚ˆã†ã«ãƒ‡ãƒ—ãƒ­ã‚¤ç”¨ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã¨ãƒ†ã‚¹ãƒˆãƒãƒƒãƒˆã¸ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’è¨˜è¼‰ã—ã¾ã™ã€‚ãƒ‡ãƒ—ãƒ­ã‚¤ç”¨ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãŒãªã‘ã‚Œã°ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã§ä½œæˆã—ã¾ã™ã€‚

```
flow accounts create 
```

```json:flow.json
{
    ...,
    "accounts": {
      "gacha-nft-deploy-account": {
        "address": "5a9a22c936e8866e",
        "key": {
          "type": "file",
          "location": "gacha-nft-deploy-account.pkey"
        }
      },
    },
  	"deployments": {
      "testnet": {
        "gacha-nft-deploy-account": [
          "Gacha",
          "GachaNFT",
          "FungibleToken",
          "MetadataViews",
          "NonFungibleToken"
        ]
      }
    }
}
```

è¿½è¨˜ã§ããŸã‚‰ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã¦ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’ãƒ‡ãƒ—ãƒ­ã‚¤ã—ã¾ã™ã€‚

```
flow project deploy --network=testnet
```

## ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã®å®Ÿè£…

ä»Šå›ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã«ã¯Next.jsã‚’ä½¿ç”¨ã—å®Ÿè£…ã—ãŸã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¨ã®é€šä¿¡ã‚’ã—ã¦ã¿ã¾ã™ã€‚

### ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—

init
```
npx create-next-app@latest nft-gacha-web
```

Flowã‹ã‚‰JSã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¨ã—ã¦FCLãŒæä¾›ã•ã‚Œã¦ã„ã‚‹ã®ã§ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¾ã™ã€‚
```
npm install @onflow/fcl --save
```

FCLã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã€FCLã®è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®é…ç½®ãŒå¿…è¦ã«ãªã‚Šã¾ã™ã€‚ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«```flow/config.js```ã‚’ä½œæˆã—ä»¥ä¸‹ã®ã‚ˆã†ã«è¨˜è¼‰ã—ã¾ã™ã€‚

```js:config.js
import { config } from '@onflow/fcl';

config({
  'accessNode.api': 'https://rest-testnet.onflow.org', // Mainnet: "https://rest-mainnet.onflow.org"
  'discovery.wallet': 'https://fcl-discovery.onflow.org/testnet/authn', // Mainnet: "https://fcl-discovery.onflow.org/authn"
  '0xGacha': '0x5a9a22c936e8866e',
});
```

ä»Šå›å®Ÿè£…ã—ãŸNFTã‚¬ãƒãƒ£ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’```0xGacha```ã¨ã„ã†ã‚­ãƒ¼ã«æŒ‡å®šã—ã¦ã„ã¾ã™ã€‚```0x```ã¨ã„ã†ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã§è¨­å®šã™ã‚‹ã“ã¨ã§å¾Œè¿°ã™ã‚‹transactionã‚„scriptã«æŒ‡å®šã™ã‚‹cadenceã‚³ãƒ¼ãƒ‰å†…ã®importã§```0xGacha```ã¨ã„ã†åå‰ã§importã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

### ã‚¦ã‚©ãƒ¬ãƒƒãƒˆæ¥ç¶šå‡¦ç†

Flowã«ãŠã‘ã‚‹ã‚¦ã‚©ãƒ¬ãƒƒãƒˆæ¥ç¶šã¯FCLã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã§éå¸¸ã«ç°¡å˜ã«å®Ÿè£…ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ä»¥ä¸‹ã®ã‚ˆã†ãªã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯ã‚¹ã‚’ä½œæˆã—ã¾ã™ã€‚

```ts:useConnect.ts
import { useEffect, useState } from 'react';
import * as fcl from '@onflow/fcl';

type User = {
  loggedIn?: boolean;
  addr?: string;
};

export const useConnect = () => {
  const [user, setUser] = useState<User>({
    loggedIn: undefined,
    addr: undefined,
  });

  useEffect(() => fcl.currentUser.subscribe(setUser), []);

  return {
    user,
    unauthenticate: fcl.unauthenticate,
    logIn: fcl.logIn,
    signUp: fcl.signUp,
  };
};
```

importã—ãŸfclã‹ã‚‰```subscribe()```, ```unauthenticate()```, ```logIn()```, ```signUp()```ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚

Headerã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã§ä»¥ä¸‹ã®ã‚ˆã†ã«ä½¿ç”¨ã—ã¾ã™ã€‚

```ts:Header.tsx
import Head from 'next/head';
import { useConnect } from '../hooks/useConnect';

const Header = () => {
  const { user, unauthenticate, logIn, signUp } = useConnect();

  // èªè¨¼æ¸ˆã¿
  const AuthedState = () => {
    return (
      <div className="flex items-center">
        <div className="p-3">My Address: {user?.addr ?? 'No Address'}</div>
        <button
          onClick={unauthenticate}
          className="m-4 ml-2 cursor-pointer rounded border-none bg-blue-700 p-3 hover:bg-blue-300"
        >
          Log Out
        </button>
      </div>
    );
  };

  // æœªèªè¨¼
  const UnauthenticatedState = () => {
    return (
      <div className="flex items-center">
        <button
          onClick={logIn}
          className="m-4 cursor-pointer rounded border-none bg-blue-700 p-3 hover:bg-blue-300"
        >
          Log In
        </button>
        <button
          onClick={signUp}
          className="m-4 cursor-pointer rounded border-none bg-blue-700 p-3 hover:bg-blue-300"
        >
          Sign Up
        </button>
      </div>
    );
  };

  return (
    <div className="flex h-20 justify-between bg-slate-700 align-middle">
      <Head>
        <title>FCL Quickstart with NextJS</title>
        <meta name="description" content="My first web3 app on Flow!" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <div className="flex items-center">
        <h1 className="p-2 text-3xl text-blue-300">Flow App</h1>
      </div>
      {user.loggedIn ? <AuthedState /> : <UnauthenticatedState />}
    </div>
  );
};

export default Header;
```

signInã‚‚ã—ãã¯signUpé–¢æ•°ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ã‚¦ã‚©ãƒ¬ãƒƒãƒˆæ¥ç¶šãŒè‡ªå‹•ã§å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ç‰¹ã«è¨­å®šã—ãªã‘ã‚Œã°[blocto](https://blocto.io/), [Lilico](https://chrome.google.com/webstore/detail/lilico/hpclkefagolihohboafpheddmmgdffjm)ãŒé¸æŠã§ãã¾ã™ã®ã§ã¾ã ãªã‘ã‚Œã°ã©ã¡ã‚‰ã‹ã®ã‚¦ã‚©ãƒ¬ãƒƒãƒˆã§æ¥ç¶šã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚

loginã«æˆåŠŸã™ã‚‹ã¨userå¤‰æ•°ã«ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã¨ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒè¨­å®šã•ã‚Œã¾ã™ã€‚

### ã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¨ã®é€šä¿¡å‡¦ç†

fclã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ãƒ‡ãƒ—ãƒ­ã‚¤ã—ãŸã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«scriptã‚„transactionã‚’é€ä¿¡ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ä¾‹ãˆã°ã€scriptã‚’å®Ÿè¡Œã™ã‚‹ã«ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«```fcl.query()```ã«cadenceã‚³ãƒ¼ãƒ‰ã‚’ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã¨ã—ã¦æ¸¡ã—ã¾ã™ã€‚

```ts
    // ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®ã‚¢ã‚¤ãƒ†ãƒ æ•°ã‚’å–å¾—ã™ã‚‹
  const getAmounts = async (addr: string) => {
    try {
      const items = await fcl.query({
        cadence: `
          import GachaNFT from 0xGacha
          import Gacha from 0xGacha
          pub fun main(address: Address): {UInt64: UInt32} {
            let account = getAuthAccount(address)
            let ref = account.borrow<&GachaNFT.Collection>(from: GachaNFT.CollectionStoragePath) ?? panic("Does not store collection at the storage path.")
            return ref.getAmounts()
          }
        `,
        args: (arg: any, t: any) => [arg(addr, t.Address)],
      });
      return items;
    } catch (e: unknown) {
      console.log(e);
    }
  };
```

toransactionã‚’é€ä¿¡ã™ã‚‹å ´åˆã¯```mutate()```ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

```ts
  // setup minter
  const setupMinter = async (): Promise<Transaction> => {
    const transactionId = await fcl.mutate({
      cadence: `
        import GachaNFT from 0xGacha
        import NonFungibleToken from 0xGacha
        transaction {
          prepare(signer: AuthAccount) {
            let minter <- GachaNFT.createNFTMinter()
            signer.save(<- minter, to: GachaNFT.MinterStoragePath)
            log("complete setup minter!!")
          }
        }
      `,
      proposer: fcl.currentUser,
      payer: fcl.currentUser,
      authorizations: [fcl.currentUser],
      limit: 50,
    });
    const transaction: Transaction = await fcl.tx(transactionId).onceSealed();
    return transaction;
  };
```

## ã¾ã¨ã‚

- Flowãƒã‚§ãƒ¼ãƒ³ä¸Šã«NFTã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’å®Ÿè£…ã—ã¦ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹æµã‚Œã‚’ç´¹ä»‹ã—ã¾ã—ãŸã€‚
- FCLã‚’ä½¿ç”¨ã—ãŸãƒ•ãƒ­ãƒ³ãƒˆã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ä½œæˆã®æµã‚Œã‚’ç´¹ä»‹ã—ã¾ã—ãŸã€‚

åŸ·ç­†æ™‚ç‚¹ã§ã¾ã FCLã®TypeScriptã‚µãƒãƒ¼ãƒˆãŒã•ã‚Œã¦ã„ãªã‹ã£ãŸã®ãŒæ®‹å¿µã§ã—ãŸãŒã€ãã‚Œä»¥å¤–ã¯FCLã¯ä½¿ç”¨ã—ã‚„ã™ãã€ç°¡å˜ã«ã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¨é€šä¿¡ãŒå¯èƒ½ã§ã—ãŸã€‚ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®å®Ÿè£…ã¯Cadenceã¨ã„ã†è¨€èªã®æ©æµãŒå¼·ãã€ã‹ãªã‚Šè‡ªç”±åº¦é«˜ãã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆè¨­è¨ˆãŒã§ããã†ã ãªã¨æ„Ÿã˜ã¾ã—ãŸã€‚

ä»Šå›ã¯å­¦ç¿’ç”¨é€”ã§ä½œæˆã—ã¾ã—ãŸãŒã¡ã‚ƒã‚“ã¨ãƒ—ãƒ­ãƒ€ã‚¯ãƒˆåˆ©ç”¨ã§ãã‚‹ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’å®Ÿè£…ã§ãã‚‹ã‚ˆã†ä»Šå¾Œã‚‚Cadenceã¨Flowã®æƒ…å ±ã¯è¿½ã£ã¦ã„ããŸã„ãªã¨æ€ã„ã¾ã™ã€‚ä»¥ä¸Šï¼

ä»Šå›ã®æˆæœç‰©ã¯ã“ã¡ã‚‰ã«ãªã‚Šã¾ã™

https://github.com/JY8752/Gacha-NFT-collection