---
title: "ã€Œå®Ÿè·µãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ™ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆã€ã«ç™»å ´ã™ã‚‹æ›¸ç±è²¸å‡ºã‚·ã‚¹ãƒ†ãƒ ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ™ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆï¼ˆPBTï¼‰ã‚’Goã§æ›¸ã„ã¦ã¿ãŸã‚ˆ"
emoji: "ğŸ¥"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["go", "test", "PBT", "gopter", "rapid"]
published: true
---

ã€Œå®Ÿè·µãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ™ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆã€ã‚‚ã†ã¿ãªã•ã‚“ã¯èª­ã¿ã¾ã—ãŸã‹ï¼Ÿãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ™ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆã«ã¤ã„ã¦æ—¥æœ¬èªã§æ›¸ã‹ã‚ŒãŸè²´é‡ãªæ›¸ç±ã§ã€ãƒ©ãƒ ãƒ€ãƒãƒ¼ãƒˆã•ã‚“ã‹ã‚‰å‡ºç‰ˆã•ã‚Œã¦ã„ã¾ã™ã€‚

https://www.lambdanote.com/collections/proper-erlang-elixir

æœ¬è¨˜äº‹ã¯æ›¸ç±å†…ã«ç™»å ´ã™ã‚‹æ›¸ç±è²¸å‡ºã‚·ã‚¹ãƒ†ãƒ ã‚’é€šã—ã¦Goã§ã©ã®ã‚ˆã†ã«ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ™ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆã‚’æ›¸ã‘ã‚‹ã®ã‹ã‚’æ¤œè¨¼ã—ãŸã“ã¨ã®ã¾ã¨ã‚ã§ã™ã€‚

æ›¸ç±è²¸å‡ºã‚·ã‚¹ãƒ†ãƒ ã®ä¾‹ã¯æ›¸ç±ã®å†…å®¹ã®ä¸­ã§ã‚‚é‡è¦åº¦ã®é«˜ã„ã‚¹ãƒ†ãƒ¼ãƒˆãƒ•ãƒ«ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®è©±ã§ã™ãŒæ›¸ç±å†…ã®ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã¯å…¨ã¦Erlangã¨Elixirã§æ›¸ã‹ã‚Œã¦ã„ã‚‹ãŸã‚èª­ã¿æ…£ã‚Œã¦ã„ãªã„æ–¹ã¯ãªã‹ãªã‹ç†è§£ã™ã‚‹ã®ã«è‹¦åŠ´ã™ã‚‹ã¨æ€ã„ã¾ã™ã€‚ï¼ˆã‚ãŸã—ã¯ã ã„ã¶è‹¦åŠ´ã—ã¾ã—ãŸã€‚ï¼‰Goã§æ›¸ãã“ã¨ã§æ›¸ç±ã®å†…å®¹ã®ç†è§£ã«å°‘ã—ã§ã‚‚ã¤ãªãŒã‚Œã°ã„ã„ãªã¨æ€ã„ã¾ã™ã€‚

:::message
ç­†è€…ã¯ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ™ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆã‚„é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã«ã¤ã„ã¦å­¦ã‚“ã§ã‹ã‚‰ã¾ã æ—¥ãŒæµ…ãã€ç†è§£ãŒä¸ååˆ†ãªã¨ã“ã‚ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã‚‚ã—ä½•ã‹é–“é•ã£ãŸã“ã¨ã‚’è¨€ã£ã¦ã„ãŸã‚‰ã‚³ãƒ¡ãƒ³ãƒˆãªã©ã§ã”æŒ‡æ‘˜ãã ã•ã„ğŸ™‡â€â™‚ï¸
:::

æœ¬è¨˜äº‹ã®æˆæœç‰©

https://github.com/JY8752/go-pbt-demo

ã€Œå®Ÿè·µãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ™ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆã€ã‚’èª­ã‚“ã§ã‚‹æ™‚ã®ãƒ¡ãƒ¢

https://zenn.dev/jy8752/scraps/25b43bbe1169ff

## å¯¾è±¡èª­è€…

- Goã®åŸºæœ¬æ–‡æ³•ãŒã‚ã‹ã‚‹äºº
- å®Ÿè·µãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ™ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆã‚’èª­ã‚“ã ã‘ã©ç†è§£ãŒã„ã¾ã„ã¡ãªäºº
- å®Ÿè·µãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ™ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆã‚’ã“ã‚Œã‹ã‚‰è²·ãŠã†ã‹æ‚©ã‚“ã§ã‚‹äºº
- ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ™ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆã«èˆˆå‘³ãŒã‚ã‚‹äºº
- Goã§ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ™ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆã‚’æ›¸ããŸã„äºº

## ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ™ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆã«ã¤ã„ã¦

ã‚ãŸã—ãŸã¡ãŒæ™®æ®µæ›¸ã„ã¦ã„ã‚‹ã‚ˆã†ãªå®Ÿè£…ã®æŒ™å‹•ã‚’ç¢ºèªã™ã‚‹ã‚ˆã†ãªãƒ†ã‚¹ãƒˆã¯**äº‹ä¾‹ãƒ†ã‚¹ãƒˆ**(Example Based Testing: ä»¥é™EBTã¨å‘¼ã¶)ã¨å‘¼ã°ã‚Œã€**ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ™ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆ**(Propaty Based Testing: ä»¥é™PBTã¨å‘¼ã¶)ã¯ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ã®åŠ›ã‚’ä½¿ã„éå¸¸ã«å¤šãã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹ãƒ†ã‚¹ãƒˆæ‰‹æ³•ã§ã™ã€‚

PBTã‚’ä½¿ã†ã“ã¨ã§ã‚ã‚‰ã‚†ã‚‹ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ã‚’ç¶²ç¾…ã™ã‚‹ã“ã¨ãŒã§ãã€äº‹å‰ã«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ãƒã‚°ã‚’æ¤œçŸ¥ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã‚‚ã¨ã¯é–¢æ•°å‹è¨€èªã§ã‚ã‚‹Haskellã®QuickCheckãŒç”±æ¥ã§ã„ã‚ã„ã‚ãªè¨€èªã§PBTã‚’æ›¸ããŸã‚ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ãŒä½œæˆã•ã‚Œã¦ã„ã¾ã™ã€‚

## ãªãœãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ™ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆã‚’å­¦ã¶ã®ã‹

ã“ã‚Œã¯Findyã•ã‚“ã®ã‚¤ãƒ™ãƒ³ãƒˆã§twadaã•ã‚“ãŒãŠã£ã—ã‚ƒã£ã¦ã„ãŸã“ã¨ã§ã™ãŒä¸€èˆ¬çš„ã«æ›¸ã‹ã‚Œã‚‹EBTã«ã‚ˆã‚‹ãƒ†ã‚¹ãƒˆã¯ãƒ†ã‚¹ãƒˆã¨ã„ã†ã‚ˆã‚Šã¯ç¢ºèªã®æ„å‘³åˆã„ãŒå¼·ã„ã®ã§ãƒ†ã‚¹ãƒˆã¨ã„ã†ã«ã¯å°‘ã—é•ã†ã€‚PBTã¯ä½•ã‹ã‚’ç¢ºèªã™ã‚‹ã¨ã„ã†ã‚ˆã‚Šã‚‚é–‹ç™ºè€…ã‚‚ã‚ã‹ã‚‰ãªã„æœªçŸ¥ã®ä¸å…·åˆã‚’æ¢ç´¢ã™ã‚‹ãŸã‚ã«æ›¸ãã€‚ãªã®ã§EBTã¨PBTã¯**äº’ã„ã«ç«¶åˆã™ã‚‹ã‚‚ã®ã§ã¯ãªãè£œå®Œã—ã‚ã†ã‚‚ã®**ã€‚

```
Test = Checking(ç¢ºèª) + Explorer(æ¢ç´¢)
```

ç­†è€…ã¯å˜ä½“ãƒ†ã‚¹ãƒˆã®**è³ª**ã«ã¤ã„ã¦è€ƒãˆãŸæ™‚ã«ã€**ãƒ†ã‚¹ãƒˆãŒã—ã‚„ã™ã„é–¢æ•°è¨­è¨ˆ**ã‚’ã™ã‚‹ã“ã¨ãŒå¤§äº‹ã§ã‚ã‚Šã€**ãã®ã“ã¨ã‚’è¸ã¾ãˆãŸä¸Šã§ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å…¨ä½“ã®è¨­è¨ˆã‚’ã™ã‚‹å¿…è¦ãŒã‚ã‚‹**ã¨æ€ã£ã¦ã„ã¾ã™ã€‚ãƒ†ã‚¹ãƒˆãŒã—ã‚„ã™ã„é–¢æ•°ã¨è¨€ã†ã¨é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã§è¨­è¨ˆã•ã‚Œã‚‹ã‚ˆã†ãª**å…¥åŠ›ã«å¯¾ã—ã¦å‡ºåŠ›ãŒæ˜ç¢ºãªé–¢æ•°**ã‚’ä½œã‚ŠãŸããªã‚Šã¾ã™ã€‚ãã†ã™ã‚‹ã¨ã€é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®ä¸–ç•Œã§åºƒãä½¿ã‚ã‚Œã‚‹PBTã‚’æ›¸ããŸããªã‚Šã¾ã™ã€‚

ãã†ã—ã¦ã€ç­†è€…ã¯PBTã«ã¤ã„ã¦å­¦ã³ãŸã„ã¨æ€ã„ç«‹ã£ãŸã®ã§ã™ãŒã€**PBTã¯EBTã«ç½®ãæ›ã‚ã‚‹ã‚‚ã®ã§å¯èƒ½ãªé™ã‚ŠPBTã‚’æ›¸ãæ–¹ãŒã„ã„**ã¨æ€ã£ã¦ã„ãŸã®ã§ã™ãŒä¸Šè¿°ã—ãŸã‚ˆã†ã«ãã‚Œã¯**èª¤ã‚Š**ãªã‚ˆã†ã§ã™ã€‚

ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§**ä½•ãŒã§ãã¦ä½•ãŒã§ããªã„ã®ã‹**ã‚’ã—ã£ã‹ã‚ŠEBTã§ãƒ†ã‚¹ãƒˆã—ãŸã†ãˆã§ã€ã¾ã è¦‹ã¬æœªçŸ¥ã®ä¸å…·åˆã‚’æ¢ã—å‡ºã™ã®ã«PBTã‚’æ›¸ãã“ã¨ã§ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ä¿¡é ¼æ€§ã‚’å¤§ããå‘ä¸Šã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

## ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ™ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆã¯é›£ã—ã„

PBTã‚’æ›¸ãã“ã¨ã§ä¿¡é ¼æ€§ã®é«˜ã„ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ã‘ã‚‹ã“ã¨ã¯ã‚ã‹ã£ãŸã®ã§ã„ã–PBTã‚’æ›¸ã“ã†ã¨ã—ã¦ã‚‚ãŠãã‚‰ãå¤šãã®äººãŒã¨ã¾ã©ã†ã¨æ€ã„ã¾ã™ã€‚PBTã¯**ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼**ã¨å‘¼ã°ã‚Œã‚‹ã•ã¾ã–ã¾ãªå€¤ã‚’ç”Ÿæˆã™ã‚‹ã‚‚ã®ã‚’ä½¿ã„ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã©ã†ã‚ã‚‹ã¹ãã‹ã¨ã„ã†ã“ã¨ã‚’**ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£**ã¨ã—ã¦æ›¸ãã¾ã™ã€‚ã“ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®æ›¸ãæ–¹ãŒé›£ã—ã„ã¨ç­†è€…ã¯æ€ã£ã¦ã„ã¾ã™ã€‚

ä¾‹ãˆã°ã€Goã®sliceã®æœ€å¤§å€¤ã‚’è¿”ã™```Biggest()```ã¨ã„ã†é–¢æ•°ã«ã¤ã„ã¦è€ƒãˆã¦ã¿ã¾ã™ã€‚

```go
func Biggest(list []int) (max int) {
	for _, n := range list {
		if n > max {
			max = n
		}
	}
	return max
}
```

ã“ã®PBTã‚’æ›¸ãã¨ä»¥ä¸‹ã®ã‚ˆã†ã«æ›¸ã‘ã¾ã™ã€‚(PBTã‚’æ›¸ãã®ã«rapidã¨å‘¼ã°ã‚Œã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ãŒã“ã‚Œã«ã¤ã„ã¦ã¯å¾Œè¿°ã—ã¾ã™ã€‚)

```go
func TestBiggest(t *testing.T) {
  rapid.Check(t, func(t *rapid.T) {
    // ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼
    list := rapid.SliceOf(rapid.Int()).Draw(t, "list")

    // ãƒ†ã‚¹ãƒˆå¯¾è±¡ã®å®Ÿè¡Œ
    act := biggest.Biggest(list)

    // ã‚½ãƒ¼ãƒˆã—ã¦æœ€å¾Œã®è¦ç´ ã‚’å–å¾—ã™ã‚Œã°æœ€å¤§å€¤ã®ã¯ãš
    sort.Ints(list)
    expect := list[len(list)-1]

    // æ¤œè¨¼
    if act != expect {
      t.Errorf("biggest value is wrong act: %d expect: %d\n", act, expect)
    }
  })
}
```

ã“ã“ã§

```go
sort.Ints(list)
expect := list[len(list)-1]
```

ã“ã®ãƒ­ã‚¸ãƒƒã‚¯ãŒæ€ã„ã¤ã‘ã°ãã‚“ãªã«é ­ã‚’æ‚©ã¾ã›ã‚‹å¿…è¦ã¯ãªã„ã§ã™ãŒã€ã“ã‚ŒãŒæ€ã„ã¤ã‹ãªã„ã¨ã©ã†æ¤œè¨¼ã—ã¦ã„ã„ã®ã‹ã‚ã‹ã‚‰ãªããªã£ã¦ã—ã¾ã†äººãŒå¤šã„ã§ã—ã‚‡ã†ã€‚ã“ã‚Œã¯æ›¸ç±å†…ã§**ãƒ¢ãƒ‡ãƒ«åŒ–**ã¨ã—ã¦ç´¹ä»‹ã•ã‚Œã¦ã„ã‚‹ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æ›¸ããŸã‚ã®ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã§ã™ã€‚

PBTã«æ…£ã‚Œã¦ã„ãªã„ã§ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æ›¸ãã¨**ãƒ†ã‚¹ãƒˆå¯¾è±¡ã¨åŒã˜ãƒ­ã‚¸ãƒƒã‚¯**ã§æ¤œè¨¼ã™ã‚‹ã‚ˆã†ãªãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æ°—ã¥ã„ãŸã‚‰æ›¸ã„ã¦ã—ã¾ã„ã€ã“ã‚Œã¯ãƒ†ã‚¹ãƒˆã‚’ã™ã‚‹æ„å‘³ãŒã‚ã‚‹ã®ã‹ï¼Ÿã¨ãªã£ã¦ã—ã¾ã„ã¾ã™ã€‚ï¼ˆã‚ãŸã—ã¯ãªã‚Šã¾ã—ãŸã€‚ï¼‰

ä¸Šè¿°ã—ãŸãƒ¢ãƒ‡ãƒ«åŒ–ã¯**ãƒ†ã‚¹ãƒˆå¯¾è±¡ã¨ã¯ç•°ãªã‚‹åˆ¥ã®ãƒ­ã‚¸ãƒƒã‚¯**ã§å®Ÿè£…ã‚’ã‚‚ã†ä¸€ã¤ä½œã‚Šã€ãƒ†ã‚¹ãƒˆå¯¾è±¡ã®çµæœã¨æ¤œè¨¼ã™ã‚‹ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã§ã™ã€‚ä¸¡æ–¹ã®ãƒ­ã‚¸ãƒƒã‚¯ãŒèª¤ã£ã¦ã„ã‚‹ã¨ã„ã†ã“ã¨ã‚‚è€ƒãˆã‚‰ã‚Œã¾ã™ãŒã©ã¡ã‚‰ã‹ã®ãƒ­ã‚¸ãƒƒã‚¯ãŒèª¤ã£ã¦ã„ã‚Œã°ãƒ†ã‚¹ãƒˆãŒå¤±æ•—ã™ã‚‹ã®ã§ååˆ†ã«ä¿¡é ¼ã§ãã‚‹ãƒ†ã‚¹ãƒˆãŒæ›¸ã‘ã¾ã™ã€‚

ã“ã†ã„ã£ãŸãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã‚’çŸ¥ã‚‰ãšã«PBTã‚’æ›¸ãã®ã¯å›°é›£ã ã¨ç­†è€…ã¯æ€ã†ã®ã§ã€ä½•ã‹ã—ã‚‰ã§ä¸€åº¦PBTã«ã¤ã„ã¦ä½“ç³»çš„ã«å­¦ã‚“ã æ–¹ãŒè‰¯ã„ã§ã—ã‚‡ã†ã€‚

ã¡ãªã¿ã«ã€ä¸Šè¨˜ã®```Biggest()```ã®ãƒ†ã‚¹ãƒˆã«ã¯ä¸å…·åˆãŒã‚ã‚Šã€ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã™ã‚‹ã¨ä»¥ä¸‹ã®ã‚ˆã†ãªã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã™ã€‚

```
[rapid] panic after 0 tests: runtime error: index out of range [-1]
```

ã“ã‚Œã¯ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ãŒç©ºã®sliceã‚’ä½œæˆã™ã‚‹ã¨

```go
expect := list[len(list)-1]
```

ã“ã“ã§panicã™ã‚‹ã‹ã‚‰ã§ã™ã€‚ã“ã®å ´åˆã€ã„ãã¤ã‹å¯¾å¿œã¯è€ƒãˆã‚‰ã‚Œã¾ã™ãŒã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ã§ç©ºã®sliceã‚’ä½œæˆã—ãªã„ã‚ˆã†ã«ã™ã‚‹ãªã©ãŒè€ƒãˆã‚‰ã‚Œã¾ã™ã€‚

ã¾ãŸã€ç©ºã®sliceã‚’ä½œæˆã—ãªã„ã‚ˆã†ã«ã—ã¦ã‚‚ãƒ†ã‚¹ãƒˆã¯ã¾ã å¤±æ•—ã—ã¦ã—ã¾ã„ã¾ã™ã€‚

```
[rapid] draw list: []int{-1}
```

ã“ã‚Œã¯```[]int{-1}```ã¨ã„ã†sliceãŒ```Biggest()```ã®å¼•æ•°ã«æ¸¡ã£ãŸæ™‚ã«zeroå€¤ã®0ãŒé–¢æ•°ã®æˆ»ã‚Šå€¤ã¨ãªã£ã¦ã—ã¾ã†ãŸã‚ã§ã™ã€‚ã“ã‚Œã¯æ˜ç¢ºã«å®Ÿè£…ãƒã‚°ãªã®ã§```Biggest()```ã‚’ä¿®æ­£ã™ã¹ãã§ã™ã€‚

```go
func Biggest(list []int) (int, error) {
	if len(list) == 0 {
		return 0, errors.New("empty list")
	}

	max := list[0]
	for _, n := range list {
		if n > max {
			max = n
		}
	}
	return max, nil
}
```

ã“ã®ã‚ˆã†ã«PBTã¯ãƒ†ã‚¹ãƒˆã¨ä¿®æ­£ã®ã‚µã‚¤ã‚¯ãƒ«ã‚’ãƒ†ã‚¹ãƒˆãŒæˆåŠŸã™ã‚‹ã¾ã§ä½•å›ã‚‚å›ã™ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ã“ã®ä¾‹ã§ã¯é–¢æ•°ã®ãƒ­ã‚¸ãƒƒã‚¯ãŒã‚·ãƒ³ãƒ—ãƒ«ãªã®ã§ã¡ã‚ƒã‚“ã¨EBTã®ãƒ†ã‚¹ãƒˆã‚’æ›¸ã„ã¦ã„ã‚Œã°æ°—ã¥ãã“ã¨ãŒã§ããŸã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€ã‚ˆã‚Šè¤‡é›‘ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹ã¨ãã«PBTã¯å¼·åŠ›ãªãƒ†ã‚¹ãƒˆæ‰‹æ³•ã¨ãªã‚‹ã¨ã„ã†ã“ã¨ãŒå°‘ã—ã¯æ„Ÿã˜ã‚ŒãŸã§ã—ã‚‡ã†ã‹ï¼Ÿï¼Ÿ

## Goã§ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ™ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆã‚’æ›¸ãã«ã¯

Goã§PBTã‚’æ›¸ããŸã‚ã«ã¯åŸ·ç­†æ™‚ç‚¹ã§ä»¥ä¸‹ã®ï¼’ç¨®é¡ã®é¸æŠè‚¢ãŒã‚ã‚Šã¾ã™ã€‚

- [leanovate/gopter](https://github.com/leanovate/gopter)
- [pgregory.net/rapid](https://github.com/flyingmutant/rapid)

é•ã„ã¨ã—ã¦ã¯rapidã®æ–¹ãŒå¾Œç™ºã§ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã‚’ä½¿ç”¨ã—ã¦ä½œã‚‰ã‚Œã¦ã„ã‚‹ãŸã‚å‹å®‰å…¨ã‹ã¤ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ãªã£ã¦ã„ã¾ã™ã€‚ä¸€æ–¹ã€gopterã¯rapidã‚ˆã‚Šã‚‚æ©Ÿèƒ½ãŒè±Šå¯Œã§ã™ãŒ```intreface{}```ãŒå¤šãä½¿ã‚ã‚Œã¦ã„ã‚‹ãŸã‚ã‚­ãƒ£ã‚¹ãƒˆã™ã‚‹å ´é¢ãŒå¤šããªã‚Šã¾ã™ã€‚è©³ã—ãã¯ä¸¡è€…ã‚’æ¯”è¼ƒã—ãŸä»¥ä¸‹ã®ã‚¹ã‚¯ãƒ©ãƒƒãƒ—ã‚’ã”å‚ç…§ãã ã•ã„ã€‚

https://zenn.dev/jy8752/scraps/7b2870c2e10e8f

ä»Šå›ã¯ã‚·ãƒ³ãƒ—ãƒ«ã«åˆ©ç”¨ã—ãŸã‹ã£ãŸãŸã‚rapidã‚’ä½¿ç”¨ã—ã¦PBTã‚’æ›¸ã„ã¦ã„ãã¾ã™ã€‚

```
go get pgregory.net/rapid
```

## æ›¸ç±è²¸å‡ºã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…

æ›¸ç±è²¸å‡ºã‚·ã‚¹ãƒ†ãƒ ã¯DBã‚’ç”¨ã„ã¦å®Ÿè£…ã™ã‚‹ãŸã‚ã€ä»Šå›ã¯ãƒ†ã‚¹ãƒˆæ™‚ã®DBç’°å¢ƒã«[dockertest](https://github.com/ory/dockertest)ã€ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆã®ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã«[golang-migrate](https://github.com/golang-migrate/migrate)ã€SQLã‚’Goã‚³ãƒ¼ãƒ‰ã¨ã—ã¦æ‰±ã†ãŸã‚ã«[sqlc](https://github.com/sqlc-dev/sqlc)ã‚’æ¡ç”¨ã—ã¦ã„ã¾ã™ã€‚

```sql
-- æ›¸ç±ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç”¨ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã™ã‚‹ -- :setup_table_books
CREATE TABLE books (
  isbn varchar(20) PRIMARY KEY,
  title varchar(256) NOT NULL, 
  author varchar(256) NOT NULL, 
  owned smallint DEFAULT 0, 
  available smallint DEFAULT 0
);



-- æœ¬ã‚’è¿½åŠ ã™ã‚‹
-- name: AddBook :exec
INSERT INTO books (isbn, title, author, owned, available)
VALUES (?, ?, ?, ?, ?);

-- æ—¢å­˜ã®æœ¬ã‚’1å†Šè¿½åŠ ã™ã‚‹ 
-- name: AddCopy :execresult
UPDATE books SET
  owned = owned + 1,
  available = available + 1 
WHERE 
  isbn = ?;

-- æœ¬ã‚’1å†Šå€Ÿã‚Šã‚‹
-- name: BorrowCopy :execresult
UPDATE books SET available = available - 1 WHERE isbn = ? AND available > 0;

-- æœ¬ã‚’è¿”å´ã™ã‚‹
-- name: ReturnCopy :execresult
UPDATE books SET available = available + 1 WHERE isbn = ?;

-- æœ¬ã‚’è¦‹ã¤ã‘ã‚‹
-- name: FindByAuthor :many
SELECT * FROM books WHERE author LIKE ?;

-- name: FindByIsbn :one
SELECT * FROM books WHERE isbn = ?;

-- name: FindByTitle :many
SELECT * FROM books WHERE title LIKE ?; 
```

ä½¿ã†ãƒ†ãƒ¼ãƒ–ãƒ«ã¯```books```ã¨ã„ã†ãƒ†ãƒ¼ãƒ–ãƒ«ã®ã¿ã§ã€æœ¬ã®è¿½åŠ ã€è²¸å‡ºã€è¿”å´ã¨ã„ã£ãŸæ“ä½œç”¨ã®ã‚¯ã‚¨ãƒªã‚’å®šç¾©ã—ã¦ã„ã¾ã™ã€‚

ã“ã®ã‚¯ã‚¨ãƒªã‚’ã‚‚ã¨ã«Goã‚³ãƒ¼ãƒ‰ã‚’ä½œæˆã—ã¾ã™ã€‚

```
sqlc generate
```

ç”Ÿæˆã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ‰ã¯ä»¥ä¸‹ã®ã‚ˆã†ãªã‚‚ã®ã§ã™ã€‚

:::details query.sql.go
```go
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: query.sql

package infrastructure

import (
	"context"
	"database/sql"
)

const addBook = `-- name: AddBook :exec
INSERT INTO books (isbn, title, author, owned, available)
VALUES (?, ?, ?, ?, ?)
`

type AddBookParams struct {
	Isbn      string
	Title     string
	Author    string
	Owned     sql.NullInt32
	Available sql.NullInt32
}

// æœ¬ã‚’è¿½åŠ ã™ã‚‹
func (q *Queries) AddBook(ctx context.Context, arg AddBookParams) error {
	_, err := q.db.ExecContext(ctx, addBook,
		arg.Isbn,
		arg.Title,
		arg.Author,
		arg.Owned,
		arg.Available,
	)
	return err
}

const addCopy = `-- name: AddCopy :execresult
UPDATE books SET
  owned = owned + 1,
  available = available + 1 
WHERE 
  isbn = ?
`

// æ—¢å­˜ã®æœ¬ã‚’1å†Šè¿½åŠ ã™ã‚‹
func (q *Queries) AddCopy(ctx context.Context, isbn string) (sql.Result, error) {
	return q.db.ExecContext(ctx, addCopy, isbn)
}

const borrowCopy = `-- name: BorrowCopy :execresult
UPDATE books SET available = available - 1 WHERE isbn = ? AND available > 0
`

// æœ¬ã‚’1å†Šå€Ÿã‚Šã‚‹
func (q *Queries) BorrowCopy(ctx context.Context, isbn string) (sql.Result, error) {
	return q.db.ExecContext(ctx, borrowCopy, isbn)
}

const findByAuthor = `-- name: FindByAuthor :many
SELECT isbn, title, author, owned, available FROM books WHERE author LIKE ?
`

// æœ¬ã‚’è¦‹ã¤ã‘ã‚‹
func (q *Queries) FindByAuthor(ctx context.Context, author string) ([]Book, error) {
	rows, err := q.db.QueryContext(ctx, findByAuthor, author)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.Isbn,
			&i.Title,
			&i.Author,
			&i.Owned,
			&i.Available,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findByIsbn = `-- name: FindByIsbn :one
SELECT isbn, title, author, owned, available FROM books WHERE isbn = ?
`

func (q *Queries) FindByIsbn(ctx context.Context, isbn string) (Book, error) {
	row := q.db.QueryRowContext(ctx, findByIsbn, isbn)
	var i Book
	err := row.Scan(
		&i.Isbn,
		&i.Title,
		&i.Author,
		&i.Owned,
		&i.Available,
	)
	return i, err
}

const findByTitle = `-- name: FindByTitle :many
SELECT isbn, title, author, owned, available FROM books WHERE title LIKE ?
`

func (q *Queries) FindByTitle(ctx context.Context, title string) ([]Book, error) {
	rows, err := q.db.QueryContext(ctx, findByTitle, title)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.Isbn,
			&i.Title,
			&i.Author,
			&i.Owned,
			&i.Available,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const returnCopy = `-- name: ReturnCopy :execresult
UPDATE books SET available = available + 1 WHERE isbn = ?
`

// æœ¬ã‚’è¿”å´ã™ã‚‹
func (q *Queries) ReturnCopy(ctx context.Context, isbn string) (sql.Result, error) {
	return q.db.ExecContext(ctx, returnCopy, isbn)
}
```
:::

ç”Ÿæˆã—ãŸã‚³ãƒ¼ãƒ‰ã‚’ç”¨ã„ã¦ä»¥ä¸‹ã®ã‚ˆã†ãªRepositoryã‚’ä½œæˆã—ã¾ã™ã€‚

```go:repository.go
package book

import (
	"context"
	"database/sql"
	"fmt"
	"go-pbt/infrastructure"
)

type BookRepository interface {
	AddBook(ctx context.Context, isbn, title, author string, options ...addBookOptions) error
	AddCopy(ctx context.Context, isbn string) error
	BorrowCopy(ctx context.Context, isbn string) error
	ReturnCopy(ctx context.Context, isbn string) error
	FindBookByAuthor(ctx context.Context, author string) ([]infrastructure.Book, error)
	FindBookByIsbn(ctx context.Context, isbn string) (infrastructure.Book, error)
	FindBookByTitle(ctx context.Context, title string) ([]infrastructure.Book, error)
}

type bookRepository struct {
	q *infrastructure.Queries
}

func NewRepository(db *sql.DB) *bookRepository {
	return &bookRepository{q: infrastructure.New(db)}
}

type addBookOption struct {
	Owned sql.NullInt32
	Avail sql.NullInt32
}

type addBookOptions func(*addBookOption)

func WithOwned(owned int32) addBookOptions {
	return func(o *addBookOption) {
		o.Owned = sql.NullInt32{Int32: owned, Valid: true}
	}
}

func WithAvail(avail int32) addBookOptions {
	return func(o *addBookOption) {
		o.Avail = sql.NullInt32{Int32: avail, Valid: true}
	}
}

func (br *bookRepository) AddBook(ctx context.Context, isbn, title, author string, options ...addBookOptions) error {
	var op addBookOption
	for _, option := range options {
		option(&op)
	}

	params := infrastructure.AddBookParams{
		Isbn:      isbn,
		Title:     title,
		Author:    author,
		Owned:     op.Owned,
		Available: op.Avail,
	}

	return br.q.AddBook(ctx, params)
}

func checkAffected(result sql.Result) error {
	rows, err := result.RowsAffected()
	if err != nil {
		return err
	}

	if rows == 0 {
		return fmt.Errorf("not affected")
	}

	return nil
}

func (br *bookRepository) AddCopy(ctx context.Context, isbn string) error {
	result, err := br.q.AddCopy(ctx, isbn)
	if err != nil {
		return err
	}

	return checkAffected(result)
}

func (br *bookRepository) BorrowCopy(ctx context.Context, isbn string) error {
	result, err := br.q.BorrowCopy(ctx, isbn)
	if err != nil {
		return err
	}

	return checkAffected(result)
}

func (br *bookRepository) ReturnCopy(ctx context.Context, isbn string) error {
	result, err := br.q.ReturnCopy(ctx, isbn)
	if err != nil {
		return err
	}

	return checkAffected(result)
}

func (br *bookRepository) FindBookByAuthor(ctx context.Context, author string) ([]infrastructure.Book, error) {
	return br.q.FindByAuthor(ctx, "%"+author+"%")
}

func (br *bookRepository) FindBookByIsbn(ctx context.Context, isbn string) (infrastructure.Book, error) {
	return br.q.FindByIsbn(ctx, isbn)
}

func (br *bookRepository) FindBookByTitle(ctx context.Context, title string) ([]infrastructure.Book, error) {
	return br.q.FindByTitle(ctx, "%"+title+"%")
}

```

## ã‚¹ãƒ†ãƒ¼ãƒˆãƒ•ãƒ«ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ†ã‚¹ãƒˆ

ã„ã‚ˆã„ã‚ˆæœ¬é¡Œã®ã‚¹ãƒ†ãƒ¼ãƒˆãƒ•ãƒ«ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æ›¸ã„ã¦ã„ãã¾ã™ã€‚ç°¡å˜ã«èª¬æ˜ã—ã¦ãŠãã¨PBTã«ã¯**ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¬ã‚¹ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£**ã¨çŠ¶æ…‹ã‚’ç®¡ç†ã™ã‚‹**ã‚¹ãƒ†ãƒ¼ãƒˆãƒ•ãƒ«ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£**ã®ï¼’ç¨®é¡ãŒå­˜åœ¨ã—ã¾ã™ã€‚

ä»Šå›ãƒ†ã‚¹ãƒˆã™ã‚‹æ›¸ç±è²¸å‡ºã‚·ã‚¹ãƒ†ãƒ ã¯DBã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’æ›´æ–°ãƒ»å–å¾—ã™ã‚‹ãŸã‚ã€ãƒ†ã‚¹ãƒˆå¯¾è±¡ã®Repositoryã®é–¢æ•°ã‚’å®Ÿè¡Œã™ã‚‹åº¦ã«çŠ¶æ…‹ãŒå¤‰åŒ–ã—ã¦ã„ãã“ã¨ã«ãªã‚Šã¾ã™ã€‚ã“ã†ã„ã£ãŸãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®PBTã‚’æ›¸ãå ´åˆã€ã‚¹ãƒ†ãƒ¼ãƒˆãƒ•ãƒ«ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æ›¸ãã“ã¨ã«ãªã‚Šã¾ã™ã€‚

ã‚¹ãƒ†ãƒ¼ãƒˆãƒ•ãƒ«ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¯ã„ã‚ã‚†ã‚‹å‰¯ä½œç”¨ãŒç™ºç”Ÿã™ã‚‹ã‚ˆã†ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ãƒ†ã‚¹ãƒˆã—ãŸã„æ™‚ã«åˆ©ç”¨ã•ã‚Œã‚‹ãŸã‚å¿…ç„¶çš„ã«çµåˆãƒ†ã‚¹ãƒˆãªã©ã§ä½¿ã‚ã‚Œã‚‹ã“ã¨ãŒå¤šã„ã§ã—ã‚‡ã†ã€‚

ä»Šå›ã¯rapidã®ã‚¹ãƒ†ãƒ¼ãƒˆãƒ•ãƒ«ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æ›¸ããŸã‚ã®```rapid.T.Repeat()```ã‚’ä½¿ç”¨ã—ã¦PBTã‚’æ›¸ã„ã¦ã„ãã¾ã™ã€‚æ›¸ãæ–¹ã®ä¾‹ã¨ã—ã¦å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®ä¾‹ã‚’ä»¥ä¸‹ã«è¨˜è¼‰ã—ã¦ãŠãã¾ã™ã€‚

:::details Example(Queue)
```go
package main

import (
	"testing"

	"pgregory.net/rapid"
)

// Queue implements integer queue with a fixed maximum size.
type Queue struct {
	buf []int
	in  int
	out int
}

func NewQueue(n int) *Queue {
	return &Queue{
		buf: make([]int, n+1),
	}
}

// Precondition: Size() > 0.
func (q *Queue) Get() int {
	i := q.buf[q.out]
	q.out = (q.out + 1) % len(q.buf)
	return i
}

// Precondition: Size() < n.
func (q *Queue) Put(i int) {
	q.buf[q.in] = i
	q.in = (q.in + 1) % len(q.buf)
}

func (q *Queue) Size() int {
	return (q.in - q.out) % len(q.buf)
}

func testQueue(t *rapid.T) {
	n := rapid.IntRange(1, 1000).Draw(t, "n") // maximum queue size
	q := NewQueue(n)                          // queue being tested
	var state []int                           // model of the queue

	t.Repeat(map[string]func(*rapid.T){
		"get": func(t *rapid.T) {
			if q.Size() == 0 {
				t.Skip("queue empty")
			}

			i := q.Get()
			if i != state[0] {
				t.Fatalf("got invalid value: %v vs expected %v", i, state[0])
			}
			state = state[1:]
		},
		"put": func(t *rapid.T) {
			if q.Size() == n {
				t.Skip("queue full")
			}

			i := rapid.Int().Draw(t, "i")
			q.Put(i)
			state = append(state, i)
		},
		"": func(t *rapid.T) {
			if q.Size() != len(state) {
				t.Fatalf("queue size mismatch: %v vs expected %v", q.Size(), len(state))
			}
		},
	})
}

// Rename to TestQueue(t *testing.T) to make an actual (failing) test.
func main() {
	var t *testing.T
	rapid.Check(t, testQueue)
}
```
:::

### ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼

ã¾ãšã¯ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’ä½œæˆã—ã¦ã„ãã¾ã™ã€‚ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ã¯æ›¸ç±ã®```ISBN```ã€```Title```ã€```Author```ã®ä¸‰ç¨®é¡ãŒå¿…è¦ã§ã™ã€‚Titleã¨Authorã¯rapidã§ç”¨æ„ã•ã‚Œã¦ã„ã‚‹ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ã§å•é¡Œãªã•ãã†ã§ã™ã€‚ISBNã®æ–¹ã¯ã„ãã¤ã‹ã‚„ã‚Šæ–¹ãŒè€ƒãˆã‚‰ã‚Œãã†ã§ã™ãŒæ­£è¦è¡¨ç¾ã‚’ä½¿ç”¨ã—ã¦ç”Ÿæˆã—ã¦ã¿ã¾ã™ã€‚

```go
// ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼

// ä»•æ§˜ã«åˆã‚ã›ã¦ç”Ÿæˆã™ã‚‹æ–‡å­—åˆ—ã¯èª¿æ•´ã€€ä»Šå›ã¯ASCIIæ–‡å­—åˆ—ã¨æ•°å­—ã‹ã‚‰1-100æ–‡å­—ã®ç¯„å›²ã§ç”Ÿæˆ
func title() *rapid.Generator[string] {
	return rapid.StringOfN(rapid.RuneFrom(nil, unicode.ASCII_Hex_Digit), 1, 100, -1)
}

// ä»•æ§˜ã«åˆã‚ã›ã¦ç”Ÿæˆã™ã‚‹æ–‡å­—åˆ—ã¯èª¿æ•´ã€€ä»Šå›ã¯ASCIIæ–‡å­—åˆ—ã¨æ•°å­—ã‹ã‚‰1-100æ–‡å­—ã®ç¯„å›²ã§ç”Ÿæˆ
func author() *rapid.Generator[string] {
	return rapid.StringOfN(rapid.RuneFrom(nil, unicode.ASCII_Hex_Digit), 1, 100, -1)
}

func isbn() *rapid.Generator[string] {
	return rapid.StringMatching("(978|979)-(([0-9]|[1-9][0-9]|[1-9]{2}[0-9]|[1-9]{3}[0-9])-){2}([0-9]|[1-9][0-9]|[1-9]{2}[0-9])-[0-9X]")
}
```

```
# ISBNã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ã§ç”Ÿæˆã•ã‚Œã‚‹å€¤
979-7653-6-129-3
978-49-7449-62-X
979-1-47-4-3
978-2099-1545-129-6
978-1-1-4-7
979-493-1-125-4
979-1361-122-1-0
978-3-1-191-7
979-7-298-3-4
978-3-2800-0-4
```

ã¡ãªã¿ã«æ›¸ç±ã§è¨˜è¼‰ã•ã‚Œã¦ã„ã‚‹ISBNã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ã®Erlangã®å®Ÿè£…ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚

```erlang
isbn() ->
 ?LET(ISBN,
  [oneof(["978","979"]),
    ?LET(X, range(0,9999), integer_to_list(X)),
    ?LET(X, range(0,9999), integer_to_list(X)), 
    ?LET(X, range(0,999), integer_to_list(X)), 
    frequency([{10, range($0,$9)}, {1, "X"}])],
  iolist_to_binary(lists:join("-", ISBN))).
```

ã“ã‚Œã‚’å®Œå…¨ã«rapidã§å†ç¾ã™ã‚‹ã®ã¯é›£ã—ã‹ã£ãŸãŸã‚å°‘ã—æŒ™å‹•ã¯ç•°ãªã‚Šã¾ã™ã€‚ã‚‚ã—ã€å®Œå…¨ã«å†ç¾ã—ãŸã„å ´åˆrapidã§ã¯ãªãgopterã§ã‚ã‚Œã°å†ç¾ã§ãã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚

### çŠ¶æ…‹ç®¡ç†

ãƒ†ã‚¹ãƒˆå®Ÿè¡Œä¸­ã«ç®¡ç†ã™ã‚‹çŠ¶æ…‹ã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«ä½œæˆã—ã¾ã™ã€‚

```go
// æ›¸ç±æƒ…å ±ã®çŠ¶æ…‹
type _book struct {
	isbn   string
	author string
	title  string
	owned  int32
	avail  int32
}

func NewBook(isbn, author, title string, owned, avail int32) *_book {
	return &_book{isbn, author, title, owned, avail}
}

// çŠ¶æ…‹ç®¡ç†
type states = map[string]*_book
```

å®šç¾©ã—ãŸstatesã®keyã¯æ›¸ç±ã®ISBNã‚’æƒ³å®šã—ã¦ã„ã¦ã€valueã¯æ›¸ç±æƒ…å ±ã‚’è¡¨ã—ã¦ã„ã¾ã™ã€‚ãƒ†ã‚¹ãƒˆã§æ›¸ç±ãŒè¿½åŠ ã•ã‚Œã‚Œã°ã“ã®mapã«æ›¸ç±ãŒè¿½åŠ ã•ã‚Œã¦ã„ãã€è²¸å‡ºãƒ»è¿”å´ã¨ã„ã£ãŸæ›´æ–°æ“ä½œãŒè¡Œã‚ã‚Œã‚Œã°mapã«æ ¼ç´ã•ã‚Œã¦ã„ã‚‹æ›¸ç±æƒ…å ±ã‚‚é€£å‹•ã—ã¦æ›´æ–°ã•ã‚Œã¦ã„ãã¾ã™ã€‚

ã“ã“ã§å®šç¾©ã—ãŸstatesã¯DBã®booksãƒ†ãƒ¼ãƒ–ãƒ«ã¨å®Œå…¨ã«é€£å‹•ã™ã‚‹ã‚ˆã†ã«ãƒ†ã‚¹ãƒˆã‚’ä½œæˆã—ã¦ã„ãã¾ã™ã€‚

### ã‚³ãƒãƒ³ãƒ‰ã®å®šç¾©

æƒ³å®šã•ã‚Œã‚‹æ“ä½œã‚’å…¨ã¦å®šç¾©ã—ã¦ã„ãã¾ã™ã€‚æ›¸ç±å†…ã«ã¯æ›¸ã‹ã‚Œã¦ã„ã¾ã›ã‚“ãŒãƒ—ãƒ­ãƒ‘ãƒ†ã‚£å†…ã«å®šç¾©ã™ã‚‹æ“ä½œã®ä¸€è¦§ã‚’**ã‚³ãƒãƒ³ãƒ‰**ã¨å‘¼ã¶ã“ã¨ã¨ã—ã¾ã™ã€‚ã“ã“ã§æ³¨æ„ã—ãŸã„ã®ãŒ```æƒ³å®šã•ã‚Œã‚‹å…¨ã¦ã®æ“ä½œ=ãƒ†ã‚¹ãƒˆå¯¾è±¡ã®å…¨ã¦ã®é–¢æ•°ã®å®Ÿè¡Œ```ã§ã¯ãªã„ã“ã¨ã§ã™ã€‚æ›¸ç±ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã®ä»•æ§˜ã¨ã—ã¦æœŸå¾…ã•ã‚Œã¦ã„ã‚‹æŒ™å‹•ã¯æ›¸ç±å†…ã§ä»¥ä¸‹ã®ã‚ˆã†ã«æ›¸ã‹ã‚Œã¦ã„ã¾ã™ã€‚

```
- ã€Œã¾ã ã‚·ã‚¹ãƒ†ãƒ ã«ç™»éŒ²ã•ã‚Œã¦ã„ãªã„æœ¬ã‚’è¿½åŠ ã™ã‚‹ã€ã«æœŸå¾…ã•ã‚Œã‚‹ã®ã¯ã€ŒæˆåŠŸã€
- ã€Œã™ã§ã«ã‚·ã‚¹ãƒ†ãƒ ã«ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹æœ¬ã‚’è¿½åŠ ã™ã‚‹ã€ã«æœŸå¾…ã•ã‚Œã‚‹ã®ã¯ã€Œå¤±æ•—ã€
- ã€Œã™ã§ã«ã‚·ã‚¹ãƒ†ãƒ ã«ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹æœ¬ã®åœ¨åº«ã‚’ 1 å†Šè¿½åŠ ã™ã‚‹ã€ã«æœŸå¾…ã•ã‚Œã‚‹ã®ã¯ã€ŒæˆåŠŸ(ã™ãã«åœ¨åº«ãŒ 1 å†Šå¢—ãˆã‚‹)ã€ 
- ã€Œã¾ã ã‚·ã‚¹ãƒ†ãƒ ã«ç™»éŒ²ã•ã‚Œã¦ã„ãªã„æœ¬ã®åœ¨åº«ã‚’ 1 å†Šè¿½åŠ ã™ã‚‹ã€ã«æœŸå¾…ã•ã‚Œã‚‹ã®ã¯ã€Œã‚¨ãƒ©ãƒ¼ã€ 
- ã€Œã‚·ã‚¹ãƒ†ãƒ ã«ç™»éŒ²ã•ã‚Œã¦ã„ã¦åˆ©ç”¨å¯èƒ½ãªåœ¨åº«ãŒã‚ã‚‹æœ¬ã‚’è²¸å‡ºã™ã‚‹ã€ã«æœŸå¾…ã•ã‚Œã‚‹ã®ã¯ã€Œåœ¨åº«ãŒ 1 å†Šæ¸›ã‚‹ã€ 
- ã€Œã‚·ã‚¹ãƒ†ãƒ ã«ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ãŒåˆ©ç”¨å¯èƒ½ãªåœ¨åº«ãŒãªã„æœ¬ã‚’è²¸å‡ºã™ã‚‹ã€ã«æœŸå¾…ã•ã‚Œã‚‹ã®ã¯ã€Œè²¸å‡ºä¸èƒ½ã®ã‚¨ãƒ©ãƒ¼ã€ 
- ã€Œã‚·ã‚¹ãƒ†ãƒ ã«ç™»éŒ²ã•ã‚Œã¦ã„ãªã„æœ¬ã‚’è²¸å‡ºã™ã‚‹ã€ã«æœŸå¾…ã•ã‚Œã‚‹ã®ã¯ã€Œæ›¸ç±ãŒãªã„ã¨ã„ã†ã‚¨ãƒ©ãƒ¼ã€ 
- ã€Œã‚·ã‚¹ãƒ†ãƒ ã«ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹æœ¬ã‚’è¿”å´ã™ã‚‹ã€ã«æœŸå¾…ã•ã‚Œã‚‹ã®ã¯ã€Œåœ¨åº«ã‚’æˆ»ã™ã€ 
- ã€Œã‚·ã‚¹ãƒ†ãƒ ã«ç™»éŒ²ã•ã‚Œã¦ãªã„æœ¬ã‚’è¿”å´ã™ã‚‹ã€ã«æœŸå¾…ã•ã‚Œã‚‹ã®ã¯ã€Œåœ¨åº«ãŒãªã„ã¨ã„ã†ã‚¨ãƒ©ãƒ¼ã€ 
- ã€Œã‚·ã‚¹ãƒ†ãƒ ã«ç™»éŒ²ã•ã‚Œã¦ã„ã¦åˆ©ç”¨å¯èƒ½ãªåœ¨åº«ãŒæ¸›ã£ã¦ã„ãªã„æœ¬ã‚’è¿”å´ã™ã‚‹ã€ã«æœŸå¾…ã•ã‚Œã‚‹ã®ã‚‚ã€Œã‚¨ãƒ©ãƒ¼ã€
- ã€ŒISBN ã§æœ¬ã‚’æ¤œç´¢ã™ã‚‹ã€ã«å¯¾ã—ã€Œãã®æœ¬ãŒã‚·ã‚¹ãƒ†ãƒ ã«ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹å ´åˆã€ã«æœŸå¾…ã•ã‚Œã‚‹ã®ã¯ã€ŒæˆåŠŸã€
- ã€ŒISBN ã§æœ¬ã‚’æ¤œç´¢ã™ã‚‹ã€ã«å¯¾ã—ã€Œãã®æœ¬ãŒã‚·ã‚¹ãƒ†ãƒ ã«ç™»éŒ²ã•ã‚Œã¦ã„ãªã„å ´åˆã€ã«æœŸå¾…ã•ã‚Œã‚‹ã®ã¯ã€Œå¤±æ•—ã€ 
- ã€Œè‘—è€…åã§æœ¬ã‚’æ¤œç´¢ã™ã‚‹ã€ã«å¯¾ã—ã€Œè‘—è€…åã®ä¸€éƒ¨ã¾ãŸã¯å…¨ä½“ã¨ä¸€è‡´ã™ã‚‹æœ¬ãŒå°‘ãªãã¨ã‚‚ 1 ã¤ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ã€ã«æœŸå¾…ã•ã‚Œã‚‹ã®ã¯ã€ŒæˆåŠŸã€ 
- ã€Œæ›¸åã§æ¤œç´¢ã™ã‚‹ã€ã«å¯¾ã—ã€Œæ›¸åã®ä¸€éƒ¨ã¾ãŸã¯å…¨éƒ¨ã«ä¸€è‡´ã™ã‚‹æœ¬ãŒå°‘ãªãã¨ã‚‚ 1 ã¤ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ã€ã«æœŸå¾…ã•ã‚Œã‚‹ã®ã¯ã€ŒæˆåŠŸã€ 
- ã€Œã‚¿ã‚¤ãƒˆãƒ«ã¾ãŸã¯è‘—è€…åã§æ¤œç´¢ã™ã‚‹ã€ã«å¯¾ã—ã€Œä¸€è‡´ã™ã‚‹ã‚‚ã®ãŒãªã„ã€ã«æœŸå¾…ã•ã‚Œã‚‹ã®ã¯ã€Œç©ºã®çµæœã€
```

ã“ã‚ŒãŒä»Šå›å®šç¾©ã™ã‚‹ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®å…¨ã¦ã§ã™ã€‚è¦‹ã‚‹ã¨ã‚ã‹ã‚‹é€šã‚Š```æ›¸ç±ã‚’è¿½åŠ ã™ã‚‹```ã¨ã„ã†æ“ä½œã®æœŸå¾…ã•ã‚Œã‚‹æŒ¯ã‚‹èˆã„ãŒDBã®çŠ¶æ…‹ã«ã‚ˆã£ã¦```æˆåŠŸ```ã™ã‚‹ã¨ãã¨```å¤±æ•—```ã™ã‚‹ã¨ãã«åˆ†ã‹ã‚Œã¦ã„ã¾ã™ã€‚ã¤ã¾ã‚Šã€```æ›¸ç±ã‚’è¿½åŠ ã™ã‚‹```ã¨ã„ã†å®Ÿè£…ã¨å®šç¾©ã™ã‚‹ã‚³ãƒãƒ³ãƒ‰ã¯**æ±ºã—ã¦1å¯¾1ã§ã¯ãªã„**ã¨ã„ã†ã“ã¨ã§ã™ã€‚

ã§ã¯ã‚³ãƒãƒ³ãƒ‰ã‚’æ›¸ã„ã¦ã¿ã¾ã—ã‚‡ã†ã€‚ã¨ã‚Šã‚ãˆãšã€statesã«ä¾å­˜ã—ãªã„æ“ä½œã‚’æ—¢ã«ä½œæˆæ¸ˆã¿ã®ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’ä½¿ç”¨ã—ã¦ä»¥ä¸‹ã®ã‚ˆã†ã«ä½œæˆã—ã¾ã™ã€‚

```go
		// çŠ¶æ…‹ã«ä¾å­˜ã—ãªã„ãƒ†ã‚¹ãƒˆ
		alwaysPossible := map[string]func(*rapid.T){
			"AddBookNew": func(t *rapid.T) {
				isbn := isbn().Draw(t, "isbn")
				author := author().Draw(t, "author")
				title := title().Draw(t, "title")

				// äº‹å‰æ¡ä»¶
				if hasIsbn(states, isbn) {
					t.Skip("already exist book")
				}

				if err := br.AddBook(ctx, isbn, title, author, book.WithOwned(1), book.WithAvail(1)); err != nil {
					t.Fatalf("failed to AddBookNew isbn: %s err: %s", isbn, err.Error())
				}

				// çŠ¶æ…‹æ›´æ–°
				states[isbn] = NewBook(isbn, author, title, 1, 1)
			},
			"AddCopyNew": func(t *rapid.T) {
				isbn := isbn().Draw(t, "isbn")

				// äº‹å‰æ¡ä»¶
				if hasIsbn(states, isbn) {
					t.Skip("already exist book")
				}

				if err := br.AddCopy(ctx, isbn); err == nil {
					t.Fatal("expected error, but not error")
				}
			},
			"BorrowCopyUnkown": func(t *rapid.T) {
				isbn := isbn().Draw(t, "isbn")

				// äº‹å‰æ¡ä»¶
				if hasIsbn(states, isbn) {
					t.Skip("already exist book")
				}

				if err := br.BorrowCopy(ctx, isbn); err == nil {
					t.Fatal("expected error, but not error")
				}
			},
			"ReturnCopyUnkown": func(t *rapid.T) {
				isbn := isbn().Draw(t, "isbn")

				// äº‹å‰æ¡ä»¶
				if hasIsbn(states, isbn) {
					t.Skip("already exist book")
				}

				if err := br.ReturnCopy(ctx, isbn); err == nil {
					t.Fatal("expected error, but not error")
				}
			},
			"FindBookByIsbnUnkown": func(t *rapid.T) {
				isbn := isbn().Draw(t, "isbn")

				// äº‹å‰æ¡ä»¶
				if hasIsbn(states, isbn) {
					t.Skip("already exist book")
				}

				var err error
				if _, err = br.FindBookByIsbn(ctx, isbn); err == nil {
					t.Fatal("failed to FindBookByIsbnUnkown. expect error, but not error")
				}

				if !errors.Is(err, sql.ErrNoRows) {
					t.Fatalf("expect sql.ErrNoRows, but %v", err)
				}
			},
			"FindBookByAuthorUnkown": func(t *rapid.T) {
				author := author().Draw(t, "author")

				// äº‹å‰æ¡ä»¶
				if likeAuthor(states, author) {
					t.Skip("already exist book")
				}

				result, err := br.FindBookByAuthor(ctx, author)
				if err != nil {
					t.Fatalf("failed to FindBookByAuthorUnkown author: %s err: %s", author, err.Error())
				}

				if len(result) != 0 {
					t.Fatalf("failed to FindBookByAuthorUnkown. expect record not found, but found result: %v", result)
				}
			},
			"FindBookByTitleUnkown": func(t *rapid.T) {
				title := title().Draw(t, "title")

				// äº‹å‰æ¡ä»¶
				if likeTitle(states, title) {
					t.Skip("already exist book")
				}

				result, err := br.FindBookByTitle(ctx, title)
				if err != nil {
					t.Fatalf("failed to FindBookByTitlteUnkown title: %s err: %s", title, err.Error())
				}

				if len(result) != 0 {
					t.Fatalf("failed to FindBookByAuthorUnkown. expect record not found, but found result: %v", result)
				}
			},
		}
```

ã“ã“ã§å¤§äº‹ãªã®ã¯ãƒ†ã‚¹ãƒˆå¯¾è±¡ã®å®Ÿè¡Œå‰ã€å®Ÿè¡Œå¾Œã«**äº‹å‰æ¡ä»¶**ã‚‚ã—ãã¯**äº‹å¾Œæ¡ä»¶**ãŒã‚ã‚Œã°ç¢ºèªã™ã‚‹ã“ã¨ã¨ã€ãƒ†ã‚¹ãƒˆå¯¾è±¡ã®å®Ÿè¡Œå¾Œã«**çŠ¶æ…‹ã®æ›´æ–°**ãŒå¿…è¦ã§ã‚ã‚Œã°çŠ¶æ…‹ã‚’æ›´æ–°ã™ã‚‹ã“ã¨ã§ã™ã€‚ã‚‚ã—ã€çŠ¶æ…‹ã®æ›´æ–°ãŒæ¼ã‚Œã‚‹ã¨DBã¨çŠ¶æ…‹ã®æ•´åˆæ€§ãŒã¨ã‚Œãªããªã‚Šãƒ†ã‚¹ãƒˆãŒå¤±æ•—ã™ã‚‹ã§ã—ã‚‡ã†ã€‚

ã‚³ãƒãƒ³ãƒ‰ã¯ã“ã‚Œã§å…¨ã¦ã§ã¯ãªã**çŠ¶æ…‹ã«ä¾å­˜ã™ã‚‹æ“ä½œ**ãŒå­˜åœ¨ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€**æ—¢ã«æ›¸ç±ãŒå­˜åœ¨ã™ã‚‹çŠ¶æ…‹ã§æ›¸ç±è¿½åŠ ã‚’è¡Œã†**ã¨ã„ã£ãŸã‚ˆã†ãªæ“ä½œã§ã™ã€‚ã“ã®æ“ä½œã‚’å®šç¾©ã™ã‚‹ã«ã¯çŠ¶æ…‹ã‚’ã‚‚ã¨ã«å€¤ã‚’ç”Ÿæˆã™ã‚‹ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ãŒå¿…è¦ã«ãªã‚Šã¾ã™ã®ã§ä»¥ä¸‹ã®ã‚ˆã†ãªã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’è¿½åŠ ã—ã¾ã™ã€‚

```go
func isbnGen(states states) string {
	return elements(keys(states))
}

func authorGen(t *rapid.T, states states) string {
	s := make([]string, 0, len(states))
	for _, v := range states {
		s = append(s, partial(t, v.author))
	}
	return elements(s)
}

func titleGen(t *rapid.T, states states) string {
	s := make([]string, 0, len(states))
	for _, v := range states {
		s = append(s, partial(t, v.title))
	}
	return elements(s)
}
```

ï¼ˆç‹¬è‡ªã§å®šç¾©ã—ãŸãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¼é–¢æ•°ã¯ä»¥ä¸‹ã«è¨˜è¼‰ã—ã¦ãŠãã¾ã™ã€‚ï¼‰

:::details ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°ã®è©³ç´°
```go
// ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¼ / ãƒ˜ãƒ«ãƒ‘ãƒ¼
func keys[K comparable, V any](m map[K]V) []K {
	s := make([]K, 0, len(m))
	for k := range m {
		s = append(s, k)
	}
	return s
}

// func values[K comparable, V any](m map[K]V) []V {
// 	s := make([]V, 0, len(m))
// 	for _, v := range m {
// 		s = append(s, v)
// 	}
// 	return s
// }

func merge[K comparable, V any](m1 map[K]V, m2 map[K]V) map[K]V {
	newMap := make(map[K]V, len(m1)+len(m2))
	for k, v := range m1 {
		newMap[k] = v
	}
	for k, v := range m2 {
		newMap[k] = v
	}
	return newMap
}

// sliceã®è¦ç´ ãŒç©ºã ã¨panicã™ã‚‹
func elements[T any](s []T) T {
	switch len(s) {
	case 0:
		panic("slice is empty")
	case 1:
		return s[0]
	}
	return s[rand.Intn(len(s)-1)]
}

func partial(t *rapid.T, str string) string {
	l := len([]rune(str))
	start := rapid.IntRange(0, l-1).Draw(t, "start")
	end := rapid.IntRange(start+1, l).Draw(t, "end")

	return string([]rune(str)[start:end])
}

// func TestPartial(t *testing.T) {
// 	rapid.Check(t, func(t *rapid.T) {
// 		str := "d0"
// 		for i := 0; i < 10; i++ {
// 			fmt.Println(partial(t, str))
// 		}
// 	})
// }

func hasIsbn(states states, isbn string) bool {
	keys := keys(states)
	return slices.Contains(keys, isbn)
}

func likeAuthor(states states, author string) bool {
	if author == "" {
		return false
	}

	for _, v := range states {
		if strings.Contains(strings.ToLower(v.author), strings.ToLower(author)) {
			return true
		}
	}

	return false
}

func likeTitle(states states, title string) bool {
	if title == "" {
		return false
	}

	for _, v := range states {
		if strings.Contains(strings.ToLower(v.title), strings.ToLower(title)) {
			return true
		}
	}

	return false
}
```
:::

ä½œæˆã—ãŸã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’ä½¿ç”¨ã—çŠ¶æ…‹ã«ä¾å­˜ã—ãŸã‚³ãƒãƒ³ãƒ‰ã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«ä½œæˆã—ã¾ã™ã€‚

```go
// çŠ¶æ…‹ã«ä¾å­˜ã™ã‚‹ãƒ†ã‚¹ãƒˆ
		reliesOnState := map[string]func(*rapid.T){
			"AddBookExisting": func(t *rapid.T) {
				// ã¾ã stateãŒãªã„
				if len(states) == 0 {
					t.Skip("states is empty")
				}

				isbn := isbnGen(states)
				title := title().Draw(t, "title")
				author := author().Draw(t, "author")

				// äº‹å‰æ¡ä»¶
				if !hasIsbn(states, isbn) {
					t.Fatalf("states not include generate ISBN %s", isbn)
				}

				// duplicate keyã§ã‚¨ãƒ©ãƒ¼ã‚’æœŸå¾…
				if err := br.AddBook(ctx, isbn, title, author); err == nil {
					t.Fatal("expect error, but not error")
				}
			},
			"AddCopyExisting": func(t *rapid.T) {
				// ã¾ã stateãŒãªã„
				if len(states) == 0 {
					t.Skip("states is empty")
				}

				isbn := isbnGen(states)

				// äº‹å‰æ¡ä»¶
				if !hasIsbn(states, isbn) {
					t.Fatalf("states not include generate ISBN %s", isbn)
				}

				if err := br.AddCopy(ctx, isbn); err != nil {
					t.Fatalf("failed to AddCopyExisting isbn: %s err: %s", isbn, err.Error())
				}

				// çŠ¶æ…‹æ›´æ–°
				states[isbn].avail += 1
				states[isbn].owned += 1
			},
			"BorrowCopyAvail": func(t *rapid.T) {
				// ã¾ã stateãŒãªã„
				if len(states) == 0 {
					t.Skip("states is empty")
				}

				isbn := isbnGen(states)

				// äº‹å‰æ¡ä»¶
				if !hasIsbn(states, isbn) {
					t.Fatalf("states not include generate ISBN %s", isbn)
				}

				if states[isbn].avail == 0 {
					t.Skip("no books to borrow")
				}

				if err := br.BorrowCopy(ctx, isbn); err != nil {
					t.Fatalf("failed to BorrowCopyAvail isbn: %s err: %s", isbn, err.Error())
				}

				// çŠ¶æ…‹æ›´æ–°
				states[isbn].avail -= 1
			},
			"BorrowCopyUnavail": func(t *rapid.T) {
				// ã¾ã stateãŒãªã„
				if len(states) == 0 {
					t.Skip("states is empty")
				}

				isbn := isbnGen(states)

				// äº‹å‰æ¡ä»¶
				if !hasIsbn(states, isbn) {
					t.Fatalf("states not include generate ISBN %s", isbn)
				}

				if states[isbn].avail != 0 {
					t.Skip("can borrow book yet")
				}

				if err := br.BorrowCopy(ctx, isbn); err == nil {
					t.Fatal("expected error, but not error")
				}
			},
			"ReturnCopyExisting": func(t *rapid.T) {
				// ã¾ã stateãŒãªã„
				if len(states) == 0 {
					t.Skip("states is empty")
				}

				isbn := isbnGen(states)

				// äº‹å‰æ¡ä»¶
				if !hasIsbn(states, isbn) {
					t.Fatalf("states not include generate ISBN %s", isbn)
				}

				if states[isbn].avail == states[isbn].owned {
					t.Skip("book is full")
				}

				if err := br.ReturnCopy(ctx, isbn); err != nil {
					t.Fatalf("failed to ReturnCopyExisting isbn: %s err: %s", isbn, err.Error())
				}

				// çŠ¶æ…‹æ›´æ–°
				states[isbn].avail += 1
			},
			// "ReturnCopyFull": func(t *rapid.T) {
			// 	// ã¾ã stateãŒãªã„
			// 	if len(states) == 0 {
			// 		t.Skip("states is empty")
			// 	}

			// 	isbn := isbnGen(states)

			// 	// äº‹å‰æ¡ä»¶
			// 	if !hasIsbn(states, isbn) {
			// 		t.Fatalf("states not include generate ISBN %s", isbn)
			// 	}

			// 	if states[isbn].avail != states[isbn].owned {
			// 		t.Skip("book is not full")
			// 	}

			// 	// æœ¬å½“ã¯è²¸å‡ºãŒãªã„çŠ¶æ…‹ã§è¿”å´ã‚’ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã‚¨ãƒ©ãƒ¼ã«ã—ãŸã„ãŒãã‚Œã‚’ã™ã‚‹ã«ã¯äº‹å‰ã«DBå•ã„åˆã‚ã›ãŒå¿…è¦
			// 	// ã‚„ã£ã¦ã‚‚ã„ã„ã‚“ã ã‘ã©ä»Šå›ã¯æ‰‹æŠœãã§ã“ã®ãƒ†ã‚¹ãƒˆã¯é£›ã°ã™
			// 	if err := br.ReturnCopy(ctx, isbn); err != nil {
			// 		t.Fatalf("failed to ReturnCopyFull isbn: %s err: %s", isbn, err.Error())
			// 	}
			// },
			"FindBookByIsbnExists": func(t *rapid.T) {
				// ã¾ã stateãŒãªã„
				if len(states) == 0 {
					t.Skip("states is empty")
				}

				isbn := isbnGen(states)

				// äº‹å‰æ¡ä»¶
				if !hasIsbn(states, isbn) {
					t.Fatalf("states not include generate ISBN %s", isbn)
				}

				book, err := br.FindBookByIsbn(ctx, isbn)
				if err != nil {
					t.Fatalf("failed to FindBookByIsbnExists isbn: %s err: %s", isbn, err.Error())
				}

				assertBook(t, *states[isbn], book)
			},
			"FindBookByAuthorMatching": func(t *rapid.T) {
				// ã¾ã stateãŒãªã„
				if len(states) == 0 {
					t.Skip("states is empty")
				}

				author := authorGen(t, states)

				// äº‹å‰æ¡ä»¶
				if !likeAuthor(states, author) {
					t.Fatalf("states not include generate author %s", author)
				}

				_, err := br.FindBookByAuthor(ctx, author)
				if err != nil {
					t.Fatalf("failed to FindBookByAuthorMatching isbn: %s err: %s", author, err.Error())
				}

				// ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³
				// statesã‹ã‚‰authorãŒéƒ¨åˆ†ä¸€è‡´ã™ã‚‹æœ¬æƒ…å ±ã¨DBã‹ã‚‰å–å¾—ã—ã¦ããŸæœ¬æƒ…å ±ã‚’ã‚½ãƒ¼ãƒˆã—ã¦å®Œå…¨ã«ä¸€è‡´ã—ã¦ã„ã‚‹ã‹ç¢ºèªã™ã‚‹
				// å¿ƒæŠ˜ã‚ŒãŸã®ã§æ‰‹æŠœã
			},
			"FindBookByTitleMatching": func(t *rapid.T) {
				// ã¾ã stateãŒãªã„
				if len(states) == 0 {
					t.Skip("states is empty")
				}

				title := titleGen(t, states)

				// äº‹å‰æ¡ä»¶
				if !likeTitle(states, title) {
					t.Fatalf("states not include generate title %s", title)
				}

				_, err := br.FindBookByTitle(ctx, title)
				if err != nil {
					t.Fatalf("failed to FindBookByTitleMatching title: %s err: %s", title, err.Error())
				}

				// ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³
				// statesã‹ã‚‰titleãŒéƒ¨åˆ†ä¸€è‡´ã™ã‚‹æœ¬æƒ…å ±ã¨DBã‹ã‚‰å–å¾—ã—ã¦ããŸæœ¬æƒ…å ±ã‚’ã‚½ãƒ¼ãƒˆã—ã¦å®Œå…¨ã«ä¸€è‡´ã—ã¦ã„ã‚‹ã‹ç¢ºèªã™ã‚‹
				// å¿ƒæŠ˜ã‚ŒãŸã®ã§æ‰‹æŠœã
			},
```

ä¸€éƒ¨ã‚³ãƒãƒ³ãƒ‰ã¨ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã‚’é€”ä¸­ã§å¿ƒæŠ˜ã‚Œã¦çœç•¥ã—ã¦ã¾ã™ğŸ˜“

æœ€çµ‚çš„ãªãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚

:::details  æœ€çµ‚çš„ãªãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰
```go
package book_test

import (
	"context"
	"database/sql"
	"errors"
	"go-pbt/book"
	"go-pbt/infrastructure"
	container "go-pbt/internal"
	"log"
	"math/rand"
	"os"
	"slices"
	"strings"
	"testing"
	"unicode"

	"pgregory.net/rapid"
)

const migrationPath = "../db/migrations"

var db *sql.DB

func TestMain(m *testing.M) {
	// containerèµ·å‹•
	container, err := container.RunMySQLContainer()
	if err != nil {
		log.Fatal(err)
	}

	// ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
	if err = container.Migrate(migrationPath); err != nil {
		container.Close()
		log.Fatal(err)
	}

	db = container.DB

	code := m.Run()

	container.Close()
	os.Exit(code)
}

// æ›¸ç±æƒ…å ±ã®çŠ¶æ…‹
type _book struct {
	isbn   string
	author string
	title  string
	owned  int32
	avail  int32
}

func NewBook(isbn, author, title string, owned, avail int32) *_book {
	return &_book{isbn, author, title, owned, avail}
}

// çŠ¶æ…‹ç®¡ç†
type states = map[string]*_book

// ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¼ / ãƒ˜ãƒ«ãƒ‘ãƒ¼
func keys[K comparable, V any](m map[K]V) []K {
	s := make([]K, 0, len(m))
	for k := range m {
		s = append(s, k)
	}
	return s
}

// func values[K comparable, V any](m map[K]V) []V {
// 	s := make([]V, 0, len(m))
// 	for _, v := range m {
// 		s = append(s, v)
// 	}
// 	return s
// }

func merge[K comparable, V any](m1 map[K]V, m2 map[K]V) map[K]V {
	newMap := make(map[K]V, len(m1)+len(m2))
	for k, v := range m1 {
		newMap[k] = v
	}
	for k, v := range m2 {
		newMap[k] = v
	}
	return newMap
}

// sliceã®è¦ç´ ãŒç©ºã ã¨panicã™ã‚‹
func elements[T any](s []T) T {
	switch len(s) {
	case 0:
		panic("slice is empty")
	case 1:
		return s[0]
	}
	return s[rand.Intn(len(s)-1)]
}

func partial(t *rapid.T, str string) string {
	l := len([]rune(str))
	start := rapid.IntRange(0, l-1).Draw(t, "start")
	end := rapid.IntRange(start+1, l).Draw(t, "end")

	return string([]rune(str)[start:end])
}

// func TestPartial(t *testing.T) {
// 	rapid.Check(t, func(t *rapid.T) {
// 		str := "d0"
// 		for i := 0; i < 10; i++ {
// 			fmt.Println(partial(t, str))
// 		}
// 	})
// }

func hasIsbn(states states, isbn string) bool {
	keys := keys(states)
	return slices.Contains(keys, isbn)
}

func likeAuthor(states states, author string) bool {
	if author == "" {
		return false
	}

	for _, v := range states {
		if strings.Contains(strings.ToLower(v.author), strings.ToLower(author)) {
			return true
		}
	}

	return false
}

func likeTitle(states states, title string) bool {
	if title == "" {
		return false
	}

	for _, v := range states {
		if strings.Contains(strings.ToLower(v.title), strings.ToLower(title)) {
			return true
		}
	}

	return false
}

// ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼

// ä»•æ§˜ã«åˆã‚ã›ã¦ç”Ÿæˆã™ã‚‹æ–‡å­—åˆ—ã¯èª¿æ•´ã€€ä»Šå›ã¯ASCIIæ–‡å­—åˆ—ã¨æ•°å­—ã‹ã‚‰1-100æ–‡å­—ã®ç¯„å›²ã§ç”Ÿæˆ
func title() *rapid.Generator[string] {
	return rapid.StringOfN(rapid.RuneFrom(nil, unicode.ASCII_Hex_Digit), 1, 100, -1)
}

// ä»•æ§˜ã«åˆã‚ã›ã¦ç”Ÿæˆã™ã‚‹æ–‡å­—åˆ—ã¯èª¿æ•´ã€€ä»Šå›ã¯ASCIIæ–‡å­—åˆ—ã¨æ•°å­—ã‹ã‚‰1-100æ–‡å­—ã®ç¯„å›²ã§ç”Ÿæˆ
func author() *rapid.Generator[string] {
	return rapid.StringOfN(rapid.RuneFrom(nil, unicode.ASCII_Hex_Digit), 1, 100, -1)
}

func isbn() *rapid.Generator[string] {
	// return rapid.Custom(func(t *rapid.T) string {
	// 	a := rapid.OneOf(rapid.Just("978"), rapid.Just("979")).Draw(t, "isbn-a")
	// 	b := strconv.Itoa(rapid.IntRange(0, 9999).Draw(t, "isbn-b"))
	// 	c := strconv.Itoa(rapid.IntRange(0, 9999).Draw(t, "isbn-c"))
	// 	d := strconv.Itoa(rapid.IntRange(0, 999).Draw(t, "isbn-d"))
	// 	e := rapid.StringOfN(
	// 		rapid.RuneFrom([]rune{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'X'}),
	// 		1, 1, 1,
	// 	).Draw(t, "isbn-e")

	// 	return strings.Join([]string{a, b, c, d, e}, "-")
	// })
	return rapid.StringMatching("(978|979)-(([0-9]|[1-9][0-9]|[1-9]{2}[0-9]|[1-9]{3}[0-9])-){2}([0-9]|[1-9][0-9]|[1-9]{2}[0-9])-[0-9X]")
}

func isbnGen(states states) string {
	return elements(keys(states))
}

func authorGen(t *rapid.T, states states) string {
	s := make([]string, 0, len(states))
	for _, v := range states {
		s = append(s, partial(t, v.author))
	}
	return elements(s)
}

func titleGen(t *rapid.T, states states) string {
	s := make([]string, 0, len(states))
	for _, v := range states {
		s = append(s, partial(t, v.title))
	}
	return elements(s)
}

func TestProperty2(t *testing.T) {
	ctx := context.Background()
	br := book.NewRepository(db)
	states := make(states)

	rapid.Check(t, func(t *rapid.T) {
		// çŠ¶æ…‹ã«ä¾å­˜ã—ãªã„ãƒ†ã‚¹ãƒˆ
		alwaysPossible := map[string]func(*rapid.T){
			"AddBookNew": func(t *rapid.T) {
				isbn := isbn().Draw(t, "isbn")
				author := author().Draw(t, "author")
				title := title().Draw(t, "title")

				// äº‹å‰æ¡ä»¶
				if hasIsbn(states, isbn) {
					t.Skip("already exist book")
				}

				if err := br.AddBook(ctx, isbn, title, author, book.WithOwned(1), book.WithAvail(1)); err != nil {
					t.Fatalf("failed to AddBookNew isbn: %s err: %s", isbn, err.Error())
				}

				// çŠ¶æ…‹æ›´æ–°
				states[isbn] = NewBook(isbn, author, title, 1, 1)
			},
			"AddCopyNew": func(t *rapid.T) {
				isbn := isbn().Draw(t, "isbn")

				// äº‹å‰æ¡ä»¶
				if hasIsbn(states, isbn) {
					t.Skip("already exist book")
				}

				if err := br.AddCopy(ctx, isbn); err == nil {
					t.Fatal("expected error, but not error")
				}
			},
			"BorrowCopyUnkown": func(t *rapid.T) {
				isbn := isbn().Draw(t, "isbn")

				// äº‹å‰æ¡ä»¶
				if hasIsbn(states, isbn) {
					t.Skip("already exist book")
				}

				if err := br.BorrowCopy(ctx, isbn); err == nil {
					t.Fatal("expected error, but not error")
				}
			},
			"ReturnCopyUnkown": func(t *rapid.T) {
				isbn := isbn().Draw(t, "isbn")

				// äº‹å‰æ¡ä»¶
				if hasIsbn(states, isbn) {
					t.Skip("already exist book")
				}

				if err := br.ReturnCopy(ctx, isbn); err == nil {
					t.Fatal("expected error, but not error")
				}
			},
			"FindBookByIsbnUnkown": func(t *rapid.T) {
				isbn := isbn().Draw(t, "isbn")

				// äº‹å‰æ¡ä»¶
				if hasIsbn(states, isbn) {
					t.Skip("already exist book")
				}

				var err error
				if _, err = br.FindBookByIsbn(ctx, isbn); err == nil {
					t.Fatal("failed to FindBookByIsbnUnkown. expect error, but not error")
				}

				if !errors.Is(err, sql.ErrNoRows) {
					t.Fatalf("expect sql.ErrNoRows, but %v", err)
				}
			},
			"FindBookByAuthorUnkown": func(t *rapid.T) {
				author := author().Draw(t, "author")

				// äº‹å‰æ¡ä»¶
				if likeAuthor(states, author) {
					t.Skip("already exist book")
				}

				result, err := br.FindBookByAuthor(ctx, author)
				if err != nil {
					t.Fatalf("failed to FindBookByAuthorUnkown author: %s err: %s", author, err.Error())
				}

				if len(result) != 0 {
					t.Fatalf("failed to FindBookByAuthorUnkown. expect record not found, but found result: %v", result)
				}
			},
			"FindBookByTitleUnkown": func(t *rapid.T) {
				title := title().Draw(t, "title")

				// äº‹å‰æ¡ä»¶
				if likeTitle(states, title) {
					t.Skip("already exist book")
				}

				result, err := br.FindBookByTitle(ctx, title)
				if err != nil {
					t.Fatalf("failed to FindBookByTitlteUnkown title: %s err: %s", title, err.Error())
				}

				if len(result) != 0 {
					t.Fatalf("failed to FindBookByAuthorUnkown. expect record not found, but found result: %v", result)
				}
			},
		}

		// çŠ¶æ…‹ã«ä¾å­˜ã™ã‚‹ãƒ†ã‚¹ãƒˆ
		reliesOnState := map[string]func(*rapid.T){
			"AddBookExisting": func(t *rapid.T) {
				// ã¾ã stateãŒãªã„
				if len(states) == 0 {
					t.Skip("states is empty")
				}

				isbn := isbnGen(states)
				title := title().Draw(t, "title")
				author := author().Draw(t, "author")

				// äº‹å‰æ¡ä»¶
				if !hasIsbn(states, isbn) {
					t.Fatalf("states not include generate ISBN %s", isbn)
				}

				// duplicate keyã§ã‚¨ãƒ©ãƒ¼ã‚’æœŸå¾…
				if err := br.AddBook(ctx, isbn, title, author); err == nil {
					t.Fatal("expect error, but not error")
				}
			},
			"AddCopyExisting": func(t *rapid.T) {
				// ã¾ã stateãŒãªã„
				if len(states) == 0 {
					t.Skip("states is empty")
				}

				isbn := isbnGen(states)

				// äº‹å‰æ¡ä»¶
				if !hasIsbn(states, isbn) {
					t.Fatalf("states not include generate ISBN %s", isbn)
				}

				if err := br.AddCopy(ctx, isbn); err != nil {
					t.Fatalf("failed to AddCopyExisting isbn: %s err: %s", isbn, err.Error())
				}

				// çŠ¶æ…‹æ›´æ–°
				states[isbn].avail += 1
				states[isbn].owned += 1
			},
			"BorrowCopyAvail": func(t *rapid.T) {
				// ã¾ã stateãŒãªã„
				if len(states) == 0 {
					t.Skip("states is empty")
				}

				isbn := isbnGen(states)

				// äº‹å‰æ¡ä»¶
				if !hasIsbn(states, isbn) {
					t.Fatalf("states not include generate ISBN %s", isbn)
				}

				if states[isbn].avail == 0 {
					t.Skip("no books to borrow")
				}

				if err := br.BorrowCopy(ctx, isbn); err != nil {
					t.Fatalf("failed to BorrowCopyAvail isbn: %s err: %s", isbn, err.Error())
				}

				// çŠ¶æ…‹æ›´æ–°
				states[isbn].avail -= 1
			},
			"BorrowCopyUnavail": func(t *rapid.T) {
				// ã¾ã stateãŒãªã„
				if len(states) == 0 {
					t.Skip("states is empty")
				}

				isbn := isbnGen(states)

				// äº‹å‰æ¡ä»¶
				if !hasIsbn(states, isbn) {
					t.Fatalf("states not include generate ISBN %s", isbn)
				}

				if states[isbn].avail != 0 {
					t.Skip("can borrow book yet")
				}

				if err := br.BorrowCopy(ctx, isbn); err == nil {
					t.Fatal("expected error, but not error")
				}
			},
			"ReturnCopyExisting": func(t *rapid.T) {
				// ã¾ã stateãŒãªã„
				if len(states) == 0 {
					t.Skip("states is empty")
				}

				isbn := isbnGen(states)

				// äº‹å‰æ¡ä»¶
				if !hasIsbn(states, isbn) {
					t.Fatalf("states not include generate ISBN %s", isbn)
				}

				if states[isbn].avail == states[isbn].owned {
					t.Skip("book is full")
				}

				if err := br.ReturnCopy(ctx, isbn); err != nil {
					t.Fatalf("failed to ReturnCopyExisting isbn: %s err: %s", isbn, err.Error())
				}

				// çŠ¶æ…‹æ›´æ–°
				states[isbn].avail += 1
			},
			// "ReturnCopyFull": func(t *rapid.T) {
			// 	// ã¾ã stateãŒãªã„
			// 	if len(states) == 0 {
			// 		t.Skip("states is empty")
			// 	}

			// 	isbn := isbnGen(states)

			// 	// äº‹å‰æ¡ä»¶
			// 	if !hasIsbn(states, isbn) {
			// 		t.Fatalf("states not include generate ISBN %s", isbn)
			// 	}

			// 	if states[isbn].avail != states[isbn].owned {
			// 		t.Skip("book is not full")
			// 	}

			// 	// æœ¬å½“ã¯è²¸å‡ºãŒãªã„çŠ¶æ…‹ã§è¿”å´ã‚’ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã‚¨ãƒ©ãƒ¼ã«ã—ãŸã„ãŒãã‚Œã‚’ã™ã‚‹ã«ã¯äº‹å‰ã«DBå•ã„åˆã‚ã›ãŒå¿…è¦
			// 	// ã‚„ã£ã¦ã‚‚ã„ã„ã‚“ã ã‘ã©ä»Šå›ã¯æ‰‹æŠœãã§ã“ã®ãƒ†ã‚¹ãƒˆã¯é£›ã°ã™
			// 	if err := br.ReturnCopy(ctx, isbn); err != nil {
			// 		t.Fatalf("failed to ReturnCopyFull isbn: %s err: %s", isbn, err.Error())
			// 	}
			// },
			"FindBookByIsbnExists": func(t *rapid.T) {
				// ã¾ã stateãŒãªã„
				if len(states) == 0 {
					t.Skip("states is empty")
				}

				isbn := isbnGen(states)

				// äº‹å‰æ¡ä»¶
				if !hasIsbn(states, isbn) {
					t.Fatalf("states not include generate ISBN %s", isbn)
				}

				book, err := br.FindBookByIsbn(ctx, isbn)
				if err != nil {
					t.Fatalf("failed to FindBookByIsbnExists isbn: %s err: %s", isbn, err.Error())
				}

				assertBook(t, *states[isbn], book)
			},
			"FindBookByAuthorMatching": func(t *rapid.T) {
				// ã¾ã stateãŒãªã„
				if len(states) == 0 {
					t.Skip("states is empty")
				}

				author := authorGen(t, states)

				// äº‹å‰æ¡ä»¶
				if !likeAuthor(states, author) {
					t.Fatalf("states not include generate author %s", author)
				}

				_, err := br.FindBookByAuthor(ctx, author)
				if err != nil {
					t.Fatalf("failed to FindBookByAuthorMatching isbn: %s err: %s", author, err.Error())
				}

				// ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³
				// statesã‹ã‚‰authorãŒéƒ¨åˆ†ä¸€è‡´ã™ã‚‹æœ¬æƒ…å ±ã¨DBã‹ã‚‰å–å¾—ã—ã¦ããŸæœ¬æƒ…å ±ã‚’ã‚½ãƒ¼ãƒˆã—ã¦å®Œå…¨ã«ä¸€è‡´ã—ã¦ã„ã‚‹ã‹ç¢ºèªã™ã‚‹
				// å¿ƒæŠ˜ã‚ŒãŸã®ã§æ‰‹æŠœã
			},
			"FindBookByTitleMatching": func(t *rapid.T) {
				// ã¾ã stateãŒãªã„
				if len(states) == 0 {
					t.Skip("states is empty")
				}

				title := titleGen(t, states)

				// äº‹å‰æ¡ä»¶
				if !likeTitle(states, title) {
					t.Fatalf("states not include generate title %s", title)
				}

				_, err := br.FindBookByTitle(ctx, title)
				if err != nil {
					t.Fatalf("failed to FindBookByTitleMatching title: %s err: %s", title, err.Error())
				}

				// ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³
				// statesã‹ã‚‰titleãŒéƒ¨åˆ†ä¸€è‡´ã™ã‚‹æœ¬æƒ…å ±ã¨DBã‹ã‚‰å–å¾—ã—ã¦ããŸæœ¬æƒ…å ±ã‚’ã‚½ãƒ¼ãƒˆã—ã¦å®Œå…¨ã«ä¸€è‡´ã—ã¦ã„ã‚‹ã‹ç¢ºèªã™ã‚‹
				// å¿ƒæŠ˜ã‚ŒãŸã®ã§æ‰‹æŠœã
			},
		}

		t.Repeat(merge(alwaysPossible, reliesOnState))
	})
}

func assertBook(t *rapid.T, state _book, record infrastructure.Book) {
	t.Helper()

	if state.isbn != record.Isbn {
		t.Fatalf("different book.isbn state.isbn %s record.isbn %s", state.isbn, record.Isbn)
	}

	if state.title != record.Title {
		t.Fatalf("different book.title state.title %s record.title %s", state.title, record.Title)
	}

	if state.author != record.Author {
		t.Fatalf("different book.author state.author %s record.author %s", state.author, record.Author)
	}

	if state.owned != record.Owned.Int32 || !record.Owned.Valid {
		t.Fatalf("different book.owned state.owned %d record.owned %d", state.owned, record.Owned.Int32)
	}

	if state.avail != record.Available.Int32 || !record.Available.Valid {
		t.Fatalf("different book.avail state.avail %d record.avail %d", state.avail, record.Available.Int32)
	}
}
```
:::

ã“ã‚Œã§Goã§ã‚¹ãƒ†ãƒ¼ãƒˆãƒ•ãƒ«ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ä½¿ç”¨ã—ãŸPBTãŒæ›¸ã‘ã¾ã—ãŸï¼ï¼

## ãŠã‚ã‚Šã«

æœ¬è¨˜äº‹ã§ã¯è©³ç´°ãªPBTã«ã¤ã„ã¦ã®èª¬æ˜ã€rapidã‚„gopterã®æ›¸ãæ–¹ã®èª¬æ˜ã¯è¡Œã„ã¾ã›ã‚“ã§ã—ãŸãŒPBTã®é­…åŠ›ã‚„é›°å›²æ°—ã¯ä¼ã‚ã£ãŸã§ã—ã‚‡ã†ã‹ï¼Ÿ

ã‚ãŸã—è‡ªèº«PBTã‚’å­¦ã‚“ã§æ—¥ãŒæµ…ã„ã§ã™ã—ã€å®Ÿéš›ã®ãƒ—ãƒ­ãƒ€ã‚¯ãƒˆã§åˆ©ç”¨ã¾ã§ã¯ã§ãã¦ã„ã¾ã›ã‚“ãŒPBTã‚’åˆ©ç”¨ã™ã‚‹ä¾¡å€¤ã¯ååˆ†ã«ã‚ã‚‹ã¨æ„Ÿã˜ã¦ã„ã¾ã™ã€‚

ã‚¹ãƒ†ãƒ¼ãƒˆãƒ•ãƒ«ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¯è¤‡é›‘ã«ãªã‚ŠãŒã¡ã§é›£æ˜“åº¦ã¯é«˜ã„ã§ã™ãŒã‚¹ãƒ†ãƒ¼ãƒˆãƒ¬ã‚¹ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã§ã‚ã‚Œã°å‰²ã¨æ°—è»½ã«å°å…¥ã—ã¦ä½¿ç”¨ã—ã¦ã„ã£ã¦ã‚‚ã„ã„ã‚“ã˜ã‚ƒãªã„ã‹ãªã¨æ€ã„ã¾ã™ã€‚ã‚ãŸã—ã‚‚ä½¿ãˆãã†ã§ã‚ã‚Œã°ç©æ¥µçš„ã«ä½¿ã£ã¦ã„ããŸã„ãªã¨æ€ã£ã¦ã„ã¾ã™ã€‚

ã‚ãŸã—ã¯ãƒ©ãƒ ãƒ€ãƒãƒ¼ãƒˆã•ã‚“ã®å›ã—è€…ã§ã‚‚ä½•ã§ã‚‚ãªã„ã§ã™ãŒã‚‚ã—æœ¬è¨˜äº‹ã§PBTã«èˆˆå‘³ã‚’æŒã£ã¦ã„ãŸã ã‘ãŸãªã‚‰ã°ã€Œå®Ÿè·µãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ™ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆã€ã‚’è³¼å…¥ã™ã‚‹ã“ã¨ã‚’ãŠå‹§ã‚ã„ãŸã—ã¾ã™ã€‚é›£æ˜“åº¦ã¯é«˜ã„ã§ã™ãŒéå¸¸ã«è²´é‡ãªæŠ€è¡“æ›¸ã ã¨æ€ã„ã¾ã™ï¼

ä»Šå›ã¯ä»¥ä¸Šã§ã™ğŸ¼