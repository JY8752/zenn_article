---
"title": "なぜクリーンアーキテクチャを採用しないのか？"
---

前回の章でロンドン学派と古典学派の性質を比較し、質の良いテストを書くためには古典学派のテストの方が良いと考えられる理由を学びました。本章ではもう少し実装に寄った話でアーキテクチャについて触れていきたいと思います。

## クリーンアーキテクチャについて

クリーンアーキテクチャについては検索すればたくさん情報が落ちていますので本書では詳しい説明はしませんが以下のような同心円の図が有名です。

![](https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.amazonaws.com%2F0%2F293368%2F7ce1fb10-504e-16e0-8930-278b8a7f942d.jpeg?ixlib=rb-4.0.0&auto=format&gif-q=60&q=75&w=1400&fit=max&s=6202c326b443ad77ae7fdf47bc9bd9d1)

クリーンアーキテクチャの他にもオニオンアーキテクチャやヘキサゴナルアーキテクチャといったアーキテクチャが存在し、これらはドメイン駆動開発(DDD)で登場してくるレイヤードアーキテクチャの概念の中のドメイン層がインフラストラクチャー層、つまりDBの詳細などに依存してしまっていることを解決するようなアーキテクチャとして提唱され続けてきました。

クリーンアーキテクチャでは**依存性逆転の法則**を使用し、実装ではなく抽象に依存するようにすることでドメイン層が他のレイヤーに依存しないようにすることを実現しています。

この、抽象に依存するために具体的にどうするかというと**インターフェース**を使用します。

## クリーンアーキテクチャとモックを使用したテスト

現代の開発現場において単体テストを書いていることとクリーンアーキテクチャのようなアーキテクチャを採用している組織は非常によく見かけるようになりました。クリーンアーキテクチャは上述したようにインターフェースを作成し、インターフェースに依存するようにすることで依存関係の方向を中心に向かうように保っています。そして、単体テストで依存関係をモック化するには依存関係をインターフェースにしておくとモックに置き換えやすいです。

そのため、インターフェースを必須とするクリーンアーキテクチャとインターフェースを必要とするモックを使用したテストは相性が良いようにも見えます。

## 古典学派から見るクリーンアーキテクチャ

では、古典学派的な観点からクリーンアーキテクチャについて考えてみたいと思います。

### クリーンアーキテクチャのドメイン層が副作用を持っている

後の章でも触れていきたいと思いますが古典学派的な観点からすると重要なビジネスロジックを扱うドメイン層は**何にも依存していない方が良い**としています。これはテスト対象のコードが**ある入力に対して決まった出力をする**、つまり関数型プログラミングの世界で言う**純粋関数**が最も質の良いテストを書くことができると考えているからです。

例えば、以下のようなコードがあったとします。

```go
type UserRepository struct {}

func (u *UserRepository)FindById(userId int) {

}

type UserService struct {
	UserRep *UserRepository
}

func (u *UserService)Find(userId int) {
	// DBからユーザー情報を取得する
	user, err := u.UserRep.FindById(userId)

	...
}
```

このコードは```UserService```構造体が```UserRepository```構造体に依存しています。もし、```UserService```の```Find()```をテストするときに```UserRepository```を使用してDBからデータを取得するのは副作用でありこれは純粋関数ではありません。

サンプルが単純すぎますがクリーンアーキテクチャのようなアーキテクチャを採用しているプロダクトにおいて上記のような**最も単体テストを書きたいビジネスロジックを含んだコード**がDBなどを扱うオブジェクトに依存しているようなコードはよく見かけます。

これはクリーンアーキテクチャの話ではないのかもしれませんが、クリーンアーキテクチャを採用するとビジネスロジックを含んだコードが**副作用を含んでしまい、純粋関数として単体テストを書けない**という問題が発生します。(上記の例のようなxxxServiceのような構造体がビジネスロジックを扱っている場合の話です。)

:::message
ちなみに、古典学派の考え方として単体テストは全て純粋関数としてテストをすべきとまでは言っていません。**極力純粋関数に寄せることが大事でありこの違いは重要**だと書籍では書かれています。
:::

### 古典学派的にインターフェースは作るのでなく発見するもの

これはテストの観点だけでなくいろんなところで見かけたりしますが**インターフェースは作るのではなく発見されるもの**と古典学派でも考えられています。インターフェースは複数の実装の抽象化であり**実装が１つしかないのに抽象化すべきでない**としています。複数の実装が必要であると発見された時に初めてインターフェースは作成されるべきです。

しかし、それでもクリーンアーキテクチャにおいて依存性を逆転させるためにインターフェースは必要で、モックに差し替えるためにもインターフェースが必要となってしまいます。

古典学派的にインターフェースを極力使用すべきでないという考えは依存性の逆転の原則が必須であるクリーンアーキテクチャとは相性が悪いように筆者は思います。

## 古典学派のテストとヘキサゴナルアーキテクチャについて

ヘキサゴナルアーキテクチャとは以下の図のように中心の六角形の中にドメインを分離し、DBやユーザーとのやり取りをポートやアダプターと呼ばれる仕組みを通すことでドメイン知識を外に侵食させないためのアーキテクチャです。もう少し詳しく知りたい方は[元記事の日本語訳](https://blog.tai2.net/hexagonal_architexture.html)があるのでこちらを参照してみてください。

![](https://storage.googleapis.com/zenn-user-upload/ea4e00de5001-20231106.png)

このアーキテクチャが提唱しているドメインの隔離はクリーンやオニオンでも提唱されていることで、どのアーキテクチャを採用してもいいと筆者は考えているのですが前述した古典学派的な考えとクリーンやオニオンのような依存性逆転の法則が一人歩きしてそうなアーキテクチャを組み合わせるとつじつまが合わなくなるように感じます。

「単体テストの考え方/使い方」では具体的にどのアーキテクチャを使うといったことには言及されていませんが、たびたびヘキサゴナルアーキテクチャという言葉は登場し、おそらくベースのアーキテクチャにヘキサゴナルがあるんだろうなと思います。

ヘキサゴナルアーキテクチャで登場する用語と異なる部分もありますが書籍の中で以下のような３層レイヤーを言及している箇所もあり、これ**以上の過度な抽象レイヤーの作成は不要である**といったようなことも書かれていることから、クリーンやオニオンのようなレイヤー構造よりもヘキサゴナルのような単純なレイヤー構造をベースとしていると考えられます。

![](https://storage.googleapis.com/zenn-user-upload/4d09fc516526-20231106.png)

## まとめ

- 依存性逆転の法則が必須となるクリーンアーキテクチャはインターフェースを極力使用しない古典学派と相性が悪い(ように見える)。
- インターフェースを作ることが前提のクリーンアーキテクチャはモックを採用してしまいたくなってしまう(ように見える)。古典学派は極力モックは使用しない。
- クリーンやオニオンのような複雑な抽象レイヤーは不要であり、データ層、アプリケーション・サービス層、ドメイン層のような単純な３層で十分であると考えている。

上記の理由から本書ではアーキテクチャのベースに**ヘキサゴナルアーキテクチャ**をアーキテクチャのベースに採用しています。

ただし、**ビジネスロジックを扱うドメイン層とドメインと外部との接続を責務にしているアプリケーションサービス層が適切に分離**できるのであればクリーンやオニオンアーキテクチャがベースでも問題ないと筆者は考えます。